<html>
<head>
<title>Getting Started with Kubernetes: Architecture Basics and Definitions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Kubernetes入门:架构基础和定义</h1>
<blockquote>原文：<a href="https://www.fairwinds.com/blog/getting-started-with-kubernetes-architecture-basics-definitions#2020-05-11">https://www.fairwinds.com/blog/getting-started-with-kubernetes-architecture-basics-definitions#2020-05-11</a></blockquote><div><span id="hs_cos_wrapper_post_body" class="hs_cos_wrapper hs_cos_wrapper_meta_field hs_cos_wrapper_type_rich_text" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p>本系列面向刚接触库伯内特和GKE的工程师。它提供了Kubernetes 的<a href="/blog/what-problems-does-kubernetes-solve" rel=" noopener">基本概述、定义以及在GKE构建 </a><a href="https://www.fairwinds.com/blog/how-to-build-a-kubernetes-cluster-in-gke"> <i> Kubernetes集群</i> </a> <i>和您的第一个</i> <a href="https://www.fairwinds.com/blog/how-to-deploy-multi-tiered-web-application-with-kubernetes"> <i>多层webapp </i> </a> <i>的快速入门。如果您正在寻找更深入的帮助，请联系。</i></p>

<p>Kubernetes入门需要一些基础的架构理解。在这里，我们总结了主节点和工作节点、Kubernetes架构以及pod、标签、选择器、部署和服务的定义。</p>
<h2><strong>主节点和工作节点</strong></h2>
<p>有两种主要类型的机器——主机和工作机——都被称为节点。大多数情况下，当有人提到一个节点时，他们谈论的是一个工作者节点。</p>
<p>主节点做一些事情:</p>
<ul>
<li><strong>服务Kubernetes API</strong>——无论何时你发出一个kubectl命令，你都是在直接和其中一个主人对话。Masters通常以三个为一组运行，因此如果您丢失一个，您不会有停机时间。</li>
<li><strong>管理调度工作负载</strong>——Kubernetes提供了一种声明式的方法，将工作提交给API，以便在worker节点上进行调度。主节点通过寻找具有足够资源的工作节点来处理这种调度，并告知工作是否可以被调度。</li>
<li><strong>保持工人的状态</strong> -当工作被提交并且可以被调度或不被调度时，该“状态”由主保持。</li>
</ul>
<p>请注意，如果您使用的是GKE、EKS、AKS或其他托管的Kubernetes服务，您就不需要担心运行主节点。</p>
<p>你可能也听说过Kubernetes的“控制飞机”。这包括主节点，以及运行在worker节点上的kubelet进程。控制平面:</p>
<ul>
<li><span>维护系统中所有Kubernetes对象的记录</span></li>
<li>运行连续的控制循环来管理那些对象的状态。</li>
<li>在任何给定的时间，控制平面的控制回路将响应集群中的变化，并努力使系统中所有对象的实际状态与您提供的期望状态相匹配。</li>
</ul>
<p>工作节点是完成“工作”的地方，也是你所有应用的所在地。工人:</p>
<ul>
<li><span> <strong>运行主人安排的工作</strong> </span></li>
</ul>
<ul>
<li><span> <strong>可以被分组为子组</strong>——您可能想要运行许多不同种类的具有不同资源需求的工作负载。您可以创建具有不同资源配置文件的节点池来满足这些需求。</span></li>
<li><span> <strong>具有可读的属性，您可以通过API </strong>访问这些属性——您可能想要在具有特定操作系统或云实例类型的节点上调度工作。您可以从API中读取以下信息:</span></li>
<ul>
<li>操作系统发行版和版本</li>
<li>资源分配</li>
<li>地区</li>
</ul>
</ul>
<h2><strong>简化的Kubernetes架构示例</strong></h2>
<p><strong><img src="../Images/8aa9c1a57a7cf84b893bb4e5e9b4b7fd.png" alt="simplified Kubernetes architecture example" srcset="https://www.fairwinds.com/hs-fs/hubfs/Blog%20Images/simplified%20Kubernetes%20architecture%20example.png?width=432&amp;name=simplified%20Kubernetes%20architecture%20example.png 432w, https://www.fairwinds.com/hs-fs/hubfs/Blog%20Images/simplified%20Kubernetes%20architecture%20example.png?width=864&amp;name=simplified%20Kubernetes%20architecture%20example.png 864w, https://www.fairwinds.com/hs-fs/hubfs/Blog%20Images/simplified%20Kubernetes%20architecture%20example.png?width=1296&amp;name=simplified%20Kubernetes%20architecture%20example.png 1296w, https://www.fairwinds.com/hs-fs/hubfs/Blog%20Images/simplified%20Kubernetes%20architecture%20example.png?width=1728&amp;name=simplified%20Kubernetes%20architecture%20example.png 1728w, https://www.fairwinds.com/hs-fs/hubfs/Blog%20Images/simplified%20Kubernetes%20architecture%20example.png?width=2160&amp;name=simplified%20Kubernetes%20architecture%20example.png 2160w, https://www.fairwinds.com/hs-fs/hubfs/Blog%20Images/simplified%20Kubernetes%20architecture%20example.png?width=2592&amp;name=simplified%20Kubernetes%20architecture%20example.png 2592w" sizes="(max-width: 864px) 100vw, 864px" data-original-src="https://www.fairwinds.com/hs-fs/hubfs/Blog%20Images/simplified%20Kubernetes%20architecture%20example.png?width=864&amp;name=simplified%20Kubernetes%20architecture%20example.png"/>T2】</strong></p>
<p>来源:<a href="https://www.datadoghq.com/blog/monitoring-kubernetes-era/">数据狗</a></p>
<p>在中间，你可以看到Kubernetes的标志。这表示控制平面。如果您使用的是像GKE这样的托管服务，则该控制平面由该服务管理。</p>
<p>API在控制平面中运行。当发出一个kubectl命令时，这就是您将与之对话的内容。当工作负载提交给API时，API将在不同的工作节点上对它们进行调度。</p>
<p>该图还显示了节点A和节点b。每个工作节点都运行一个kubelet，这是一个守护进程，它与主节点交流可用资源的数量、哪些工作处于挂起状态，以及工作是否可以调度到它所管理的节点。</p>
<p>然后有一些圆荚体的表现。pod是在节点上调度的一组Docker容器。</p>
<ul>
<li>在节点A上，我们有两个不同的单元。在第一个pod中，有三个不同的容器。第二个舱里有一个集装箱。</li>
<li>在节点B上，我们有一个带有两个容器的pod。</li>
</ul>
<p>所有工作都作为这些容器分组或pod提交给Kubernetes API。为了增加弹性，Kubernetes可以在不同的节点上分发相同pod规范的多个副本，因此即使其中一个崩溃，您也有一个备份。</p>
<h2><strong>立方定义</strong></h2>
<p>当您开始使用Kubernetes API时，了解以下词汇和概念是很重要的。</p>
<p>Kubernetes被组织成一系列对象，用于典型的CRUD操作，即通过API创建、读取、更新和删除。</p>
<ul>
<li>Kubernetes声明由一系列相互关联的对象组成</li>
<li>API通过对这些对象进行更高级别的抽象来提供额外的功能</li>
<li>对象的声明存储为YAML并提交给API</li>
<li>这些YAML文件通常被签入Git存储库以进行版本控制</li>
</ul>
<h2><strong> Kubernetes豆荚</strong></h2>
<p>pod是在作为一个单元的同一物理或虚拟机上调度的一个或多个容器的集合。当您创建pod的声明时，您可以用位于pod内部的任意数量的容器来定义它。</p>
<p>pod还在内部共享一个网络——每当在pod内的所有容器之间调度一个pod时，就共享一个私有网络。他们还可以共享文件系统卷。与Docker使用- <strong> volumes-from </strong>类似，当在一个pod中运行多个容器时，这与Kubernetes的概念相同。您可以在pod内共享临时或写入时复制样式的存储。</p>
<p>通常，您不会直接创建一个pod——相反，您将创建一个更高级别的对象，如包含pod规范的Deployment或StatefulSet(见下文)。</p>
<h2><strong> Kubernetes部署</strong></h2>
<p>部署是对pod的抽象。它允许您在pod上拥有额外的功能和控制，以说明您希望跨节点运行多少个pod实例，或者您是否希望定义滚动更新策略(例如，一次仅滚动一个pod，中间等待30秒)。这使您能够根据自己的需求控制部署，以便在启用新流程和淘汰旧流程时实现零停机。</p>
<p>部署提供以下功能:</p>
<ul>
<li>提供更高级别的pod抽象(定义一组相同的pod)</li>
<li>可以扩展pod的副本以满足需求</li>
<li>负责创建、更新和删除窗格</li>
<li>可以向前或向后滚动</li>
</ul>
<p>在这里，您可以看到这个部署称为“webapp”。它希望存在两个副本。</p>
<p>它使用标签选择器(设置为“app: webapp”)来查找和管理由其生成的pod。在它的下面，你可以看到它将产生的豆荚的缩写模板，它将有标签。</p>
<pre><code>apiVersion: apps/v1beta2
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 2
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
        - name: webapp
          image: nginx
          ports:
          - containerPort: 8080
            name: http
          env:
          - name: REDIS_HOST
            value: 'redis-master'
</code></pre>
<h2><strong>不变标签</strong></h2>
<p>每个Kubernetes对象都为您提供了通过标签附加元数据的机会——一系列附加到对象上的任意键值对。通常，这些是对用户进行声明有意义的标识属性。</p>
<p>标签本质上并不意味着核心系统的语义。这意味着，对于Kubernetes系统来说，没有什么功能是你可以从标签中明确获得的。相反，它们被DevOps团队用来查询特定的对象集。</p>
<p>标签非常重要，因为它们可以用来编排、附加和识别Kubernetes系统中的不同对象。标签可以通过创建或更新操作附着到对象。您可以在创建pod时附加标签，也可以将标签应用于已经在更新过程中运行的pod。</p>
<p>我们期望许多对象具有相同的标签，因为标签不是唯一的。例如，您可能希望将所有与网站前端相关的资源标记为app=frontend，而所有后端资源都标记为app=backend。或者你希望它们都是app = website——你使用标签的方式完全取决于你。</p>
<p>以下是Kubernetes YAML定义上下文中的标签片段:</p>
<pre><code>apiVersion: v1
kind: Pod
(...)
metadata:
  labels:
    app: backend
    tier: primary
    release: staging
</code></pre>
<p>您可以将标签指定为您想要的任何东西，具有对您有意义的任何种类的语义，因为这些是您的，能够在Kubernetes系统中编排不同的事情。</p>
<h2><strong> Kubernetes Selectors </strong></h2>
<p>选择器使您能够获取Kubernetes对象，并将它们与已经应用了标签的不同对象相关联。选择器通过过滤来识别一组对象。被识别和过滤的对象集合具有相关的标签。</p>
<p>空选择器将匹配所有标签。在本例中，部署将应用于标签为“app:redis”的pod。</p>
<pre><code>kind: Deployment
metadata:
  name: webapp
Spec:
  replicas: 2
  selector:
    matchLabels:
      app: redis
  template:
    spec:
      containers:
  (...)

</code></pre>
<h2><strong>不间断服务</strong></h2>
<p>在容器和元数据的上下文之外，服务是Kubernetes的关键。服务是一种网络结构，它定义了访问pod的一致方式。如果您向Kubernetes API提交一个部署，并且该部署旋转了web服务的五个不同的pods，那么您将需要一种方法将HTTP流量路由到这些pods，使用负载平衡方法，例如循环调度。您将使用一个服务来完成这项工作。</p>
<p>服务:</p>
<ul>
<li>配置对pod的HTTP访问</li>
<li>pod之间的负载平衡流量</li>
<li>可以创建外部云资源，如负载平衡器</li>
</ul>
<p>服务找到一个pod来路由流量:</p>
<ul>
<li>在集群中，它们提供了pod之间的负载平衡</li>
<li>还可以创建外部云资源，例如云负载平衡器</li>
</ul>
<p>这是一个服务的YAML定义的例子。我们有一个名为webapp的元数据部分。在第15行我们有一个选择器。选择器是app的一个键，值为webapp。这意味着你运行的每一个带有app标签和webapp价值的pod都是相关的。任何访问此服务的流量都将被路由到与该标签匹配的pod。如果您有五个相关的pod，但其中一个崩溃，该服务将知道该pod不再健康，因此只将流量路由到其余四个，直到另一个pod出现。</p>
<pre><code>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: webapp<br/>  labels:<br/>    app: webapp<br/>spec: <br/>   type: LoadBalancer<br/>   ports:<br/>     - name: http<br/>       protocol: TCP<br/>       port: 80<br/>       targetPort: http<br/>    selector: <br/>      app: webapp</code></pre>
<p>这同样适用于水平自动缩放。例如，如果您有10个资源受限的pods在运行，Kubernetes可以增加5个标签相同的pods来处理负载。服务有责任了解现在有15个pod，流量必须相应地分配。</p>
<p>在集群中，服务提供了一种在pod之间实现负载平衡的方法。服务还可以与外部云提供商对话，并旋转云资源，如云负载平衡器，如应用程序负载平衡器(ALB)、弹性负载平衡器(elb)。这就是Kubernetes真正是云原生的原因:系统内置了许多功能，能够与您可能正在工作的任何云提供商集成。</p>
<p>有四种类型的服务。</p>
<h3><strong> <span> 1。ClusterIP:在内部IP </span> <br/> </strong>上公开服务</h3>
<p>这通常用于仅由集群中运行的其他工作负载访问的服务。Redis就是一个很好的例子。您可能不希望您的redis数据存储可以通过公共互联网进行读/写访问。您可以为Kubernetes集群中运行的redis实现分配一个ClusterIP服务，这样它只能被集群中的其他工作负载访问。</p>
<p><span> <strong> 2。NodePort:在一个静态端口</strong> </span>上公开每个工作节点IP上的服务</p>
<p>假设您有一个在五节点集群中的三台机器上运行的部署。如果您为此分配一个节点端口服务，它将直接在这些虚拟机上静态映射一个端口，并且可以从IP(不是分配给pod，而是分配给运行它们的实际节点的IP)进行访问。</p>
<p>如果您正在运行daemonsets，并且您有需要可用的监视系统的日志聚合器，这将非常有用。</p>
<p>小心端口冲突或pod重新安排。</p>
<h3><strong> <span> 3。负载平衡器:使用云提供商的负载平衡器</span> <br/> </strong>对外公开服务</h3>
<p>负载平衡器服务使用云提供商的负载平衡器对外公开服务。GCP提供云负载平衡器，AWS提供ALB和elb。在您的服务定义中，您可以请求一个负载平衡器类型，它将为您启动一个ELB来处理幕后的所有网络。请注意，这可能会导致您的云提供商支付额外费用。</p>
<h3><strong> <span> 4。ExternalName:通过返回CNAME记录</span> <br/> </strong>的DNS提供者将服务映射到外部名称</h3>
<p>类似于负载平衡器，尽管ExternalName直接与DNS提供商交互。</p>
<h2><strong> <span>现在有了这样的理解，我们将向您展示如何在GKE 建立您的<a href="/blog/how-to-build-a-kubernetes-cluster-in-gke" rel=" noopener">第一个Kubernetes集群。</a></span> </strong></h2>
<p><span class="hs-cta-wrapper" id="hs-cta-wrapper-e68d92d3-c876-4525-b775-6123e46c7212"><span class="hs-cta-node hs-cta-e68d92d3-c876-4525-b775-6123e46c7212" id="hs-cta-e68d92d3-c876-4525-b775-6123e46c7212"><a href="https://cta-redirect.hubspot.com/cta/redirect/2184645/e68d92d3-c876-4525-b775-6123e46c7212"><img class="hs-cta-img" id="hs-cta-img-e68d92d3-c876-4525-b775-6123e46c7212" src="../Images/ff6b63b515c18edd13b80bc25f17c2de.png" alt="Download the Kubernetes Best Practices Whitepaper" data-original-src="https://no-cache.hubspot.com/cta/default/2184645/e68d92d3-c876-4525-b775-6123e46c7212.png"/></a></span>T6】</span></p></span></div>    
</body>
</html>