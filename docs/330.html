<html>
<head>
<title>Docker Swarm is Dead. Long Live Kubernetes!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>码头工人已经死了。Kubernetes万岁！</h1>
<blockquote>原文：<a href="https://www.fairwinds.com/blog/docker-swarm-is-dead-long-live-kubernetes#2019-12-16">https://www.fairwinds.com/blog/docker-swarm-is-dead-long-live-kubernetes#2019-12-16</a></blockquote><div><span id="hs_cos_wrapper_post_body" class="hs_cos_wrapper hs_cos_wrapper_meta_field hs_cos_wrapper_type_rich_text" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p>在不久的将来，Docker将承认Docker Swarm已经失败，他们将不得不把发言权让给Kubernetes。要么这样，要么他们会在失败策略上加倍下注。</p>
<p>【Kubernetes获胜的原因有很多，但为了简单起见，我在这里将它们精简为几个:</p>
<h2><strong> 1) Kubernetes有社区</strong> <strong>支持</strong></h2>
<p>Kubernetes已经成为历史上最受欢迎的开源项目之一。它就在Linux内核、Chromium和自制软件的上面。考虑到大量的社区参与，该项目正在以惊人的速度进行，不断改进，发布可预测的版本，并向右上方移动。关于提交、提交者、拉请求等....毫无疑问，这是最近历史上最重要的开源项目之一。</p>
<p><span>部分是由于机构群体的支持:</span></p>
<h2><strong> 2) Kubernetes在技术上更胜一筹</strong></h2>
<p>Kubernetes和Docker Swarm都有相同的核心方法。两者都支持服务的声明性定义，这些定义被负载平衡回可变数量的容器，并与容器中安装的配置设置相结合。两者都通过优雅地将服务转移到工作节点或扩展到新节点来处理节点加入和离开群集。</p>
<p><strong> <span>然而，库伯最终胜出的那一天</span> <span> : </span> </strong></p>
<ul>
<li><span>更好的运行状况检查，在Pod级别定义了活动和就绪探测器，而不是内置于映像中。</span></li>
<li><span>与云服务集成，无缝使用负载平衡器、块存储和实例运行状况。</span></li>
<li><span>通过亲和和反亲和、DaemonSets、自动扩展、sidecars、污染和容忍以及部署更新策略，实现更好的容器调度和扩展。</span></li>
<li><span>具有基于角色的访问控制的名称空间。</span></li>
<li><span>控制服务间进出流量的网络安全策略。</span></li>
<li><span>具有运算符和自定义资源定义的可扩展性</span></li>
</ul>
<h2><strong> 3)码头工人群体被错误地激励</strong></h2>
<p>作为一家风险投资支持的公司，Docker Swarm需要为Docker赚钱，这意味着最好的功能最终将不得不以高价提供，并被开源社区拒绝。Kubernetes是由谷歌建造和支持的，谷歌有足够的资金，他们可以让数百名工程师从事这项工作，并且永远不需要对他们建造的任何东西直接收费。</p>
<p><span>可能曾经有过Docker Swarm和Kubernetes是同行的世界，但是Kubernetes赢了，</span> <span>在市场上继续赢</span> <span>。码头工人已经死了。库伯内特万岁。</span></p></span></div>    
</body>
</html>