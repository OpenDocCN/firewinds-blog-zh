<html>
<head>
<title>Hands-On With Agones and Google Cloud Game Servers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>实践Agones和Google云游戏服务器</h1>
<blockquote>原文：<a href="https://www.fairwinds.com/blog/hands-on-with-agones-google-cloud-game-servers#2020-09-09">https://www.fairwinds.com/blog/hands-on-with-agones-google-cloud-game-servers#2020-09-09</a></blockquote><div><span id="hs_cos_wrapper_post_body" class="hs_cos_wrapper hs_cos_wrapper_meta_field hs_cos_wrapper_type_rich_text" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p>我最近有幸探索了<a href="https://agones.dev/site/" target="_blank" rel="noopener"> Agones </a>和<a href="https://cloud.google.com/game-servers/" target="_blank" rel="noopener"> Google云游戏服务器(GCGS) </a>，我想分享一下我的经验。</p>

<p>Agones是一个在Kubernetes中运行多人游戏服务器的开源平台。在这次探索中，我从未运行过任何类型的游戏服务器，但是我在Kubernetes中处理过实时通信工作负载。我看到了这两种经历之间潜在的相似问题集，并好奇Agones将如何解决我在过去看到的问题。</p>
<p>在Agones之上，GCGS是一个多集群管理层，使得跨多个集群部署游戏服务器更加容易。在我更详细地介绍GCGS之前，有必要对Agones有一个更深入的了解，它是如何安装的，以及它有什么作用。</p>
<h2><strong> Agones </strong></h2>
<h3><strong>安装</strong></h3>
<p>关于Agones，我注意到的第一件事是，它完全是库伯内特斯土著。我是这个的忠实粉丝，因为这些天我在Kubernetes上运行一切；有<a href="https://agones.dev/site/docs/installation/install-agones/helm/" target="_blank" rel="noopener">安装与舵</a>指令，我立即跳转。在我的GKE集群上的初始Helm安装进展顺利，几分钟内我就有了一些自定义资源定义(CRD)和一个控制平面在agones-system名称空间中运行。</p>
<pre><code>▶ kubectl get deploy -n agones-system -oname
deployment.extensions/agones-allocator
deployment.extensions/agones-controller
deployment.extensions/agones-ping
</code></pre>
<pre><code>▶ kubectl get crd -oname | grep agones
fleetautoscalers.autoscaling.agones.dev
fleets.agones.dev
gameserverallocationpolicies.multicluster.agones.dev
gameservers.agones.dev
gameserversets.agones.dev
</code></pre>
<h3><strong>创建一个游戏服务器</strong></h3>
<p>我有一个控制器、一个分配器、一个ping服务器和一些看起来有用的CRD，但是我现在该做什么呢？遵循文档中的<a href="https://agones.dev/site/docs/getting-started/create-gameserver/" target="_blank" rel="noopener">，下一步似乎是创建一个游戏服务器。</a></p>
<p>所以我按照文档从提供的<a href="https://raw.githubusercontent.com/googleforgames/agones/release-1.8.0/examples/simple-udp/gameserver.yaml" target="_blank" rel="noopener"> yaml清单</a>中创建了一个游戏服务器。这个游戏服务器使用一个名为<span> <code>simple-udp</code> </span>的示例服务来展示Agones是如何工作的，这是我们开始了解Agones真正在做什么的地方。</p>
<p>如果我看一下gameserver规范，我会发现它包含一个容器规范，就像pod规范一样。它还通过他们所谓的<span> <code>portSpecification:</code> </span>来声明端口</p>
<pre><code>spec:
  ports:
  - name: default
    portPolicy: Dynamic
    containerPort: 7654
</code></pre>
<p>这意味着它将使用一个<span> <code>Dynamic</code> </span>外部端口，并且容器正在监听端口7654。很酷，到目前为止很简单。</p>
<p>进一步看，我可以检查gameserver以查看分配了哪个端口:</p>
<pre><code>▶ kubectl get gameserver                                                                                            
NAME               STATE   ADDRESS         PORT      AGE    
simple-udp-4pgls   Ready   35.224.97.238   7063
</code></pre>
<p>看起来我有一个运行pod并监听端口<span> <code>7063;</code> </span>的游戏服务器，现在我将尝试使用netcat通过UDP连接。</p>
<pre><code>▶ nc -u 35.224.97.238 7063   
HI                           
ACK: HI                      
EXIT                         
ACK: EXIT   
</code></pre>
<p><span> <code>simple-udp</code> </span>服务器完成了它的工作，用我发送的任何东西来响应我，然后我给出了退出命令。这个服务器的设置方式是，当它接收到一个<span> <code>EXIT</code> </span>命令时，它告诉Agones它完成了，然后Agones关闭游戏服务器。我们可以在实践中看到这一点:</p>
<pre><code>▶ kubectl get po
NAME               READY   STATUS        RESTARTS   AGE
simple-udp-4pgls   0/2     Terminating   0          30s
</code></pre>
<pre><code>▶ kubectl get gameserver
NAME               STATE      ADDRESS         PORT                                  
simple-udp-4pgls   Shutdown   35.224.97.238   7063 
</code></pre>
<p>pod终止，游戏服务器状态为<span> <code>Shutdown.</code> </span></p>
<h3><strong>关于网络和集群创建的简要说明</strong></h3>
<p>我第一次尝试连接游戏服务器时，没有任何反应。就我而言，这是因为我没有遵循Agones安装指南中所有精彩的文档。我跳过了<a href="https://agones.dev/site/docs/installation/creating-cluster/gke/" target="_blank" rel="noopener">集群创建</a>部分，因为我认为我已经知道如何创建一个集群。原来这里有一个步骤有点不同寻常。由于这些游戏服务器都需要监听UDP端口，我们需要在GCP防火墙上打开一组端口。请注意，本例中的端口范围是udp:7000-8000。此端口范围由Agones控制面板安装控制，并且可以通过舵图表中的值进行配置:</p>
<pre><code>▶ gcloud compute firewall-rules create game-server-firewall \
  --allow udp:7000-8000 \
  --target-tags game-server \
  --description "Firewall to allow game server udp traffic"
</code></pre>
<p>完成之后，我们需要用<span> <code>game-server</code> </span>标记节点，以便应用这个规则。从一开始就遵循集群创建说明要容易得多，这会让您在开始时添加标记并创建防火墙规则。</p>
<h3><strong>艾格尼丝建筑</strong></h3>
<p>你可能会问自己为什么gameserver这个东西很重要，所以我要离开探索一步，谈谈Agones实际上在做什么。</p>
<p>游戏服务器在理论上只是一个进程，多个客户端可以连接到这个进程来玩游戏。这有许多不同的实现方式，但是这些服务器必须做几件关键的事情，这会影响它们在Kubernetes中的运行方式:</p>
<span>1. Gameservers must remain available during the time that the game is being played.</span>
<p>事实上，gameserver pod必须在指定的时间内不间断，这意味着我们不能因为自动缩放、耗尽或任何其他原因而杀死pod。为了解决这个问题，gameserver以一种部署无法做到的方式管理pod生命周期。Agones为游戏服务器引入了几种状态，游戏代码本身能够通过Agones API更新这种状态。Agones在每个游戏服务器中运行一个sidecar来接收流量。</p>
<span>2. Gameservers must accept connections on some specified port from multiple clients.</span>
<p>由于端口耗尽的可能性，当在Kubernetes中运行多个游戏服务器时，这也是一个问题。我们需要一种方法来分配游戏服务器可以使用的许多不同的端口。Agones通过其动态端口分配策略无缝处理这一问题。每个游戏服务器都被分配了一个端口和一个IP组合，客户端可以使用它们进行连接。</p>
<h2><strong>谷歌云游戏服务器(GCGS) </strong></h2>
<p>既然我们已经掌握了Agones如何安装和游戏服务器如何运行的基本知识，我们可以开始看看GCGS在此基础上提供了什么。我从他们文档中的<a href="https://cloud.google.com/game-servers/docs/quickstart" target="_blank" rel="noopener">快速入门</a>指南开始。本指南要求您做的第一件事是创建一个集群并向其部署Agones。我已经完成了，所以我跳到了创建GCGS王国的部分。</p>
<h3><strong>领域</strong></h3>
<p>GCGS的领域是一个组织结构。在这个探索过程中，我试图找出将一大群全球集群组织成领域的最佳方式。我最终在Agones public Slack和一个谷歌人聊了聊。(有一个<span> <code>#google-cloud-game-servers</code> </span>频道在那里)。在这里，我不会太深入地讨论领域组织，但我得到的最佳建议是:</p>
<ul>
<li><em>一个很好的经验法则是“从玩家的角度来看，集群组之间的延迟差异无关紧要”</em></li>
</ul>
<p>反正我跑题了。一旦您有一个或一组运行Agones的集群，为了使用GCGS，您必须将它们添加到一个领域中。这很简单，用几个<span> <code>gcloud</code> </span>命令就可以做到:</p>
<pre><code>▶ gcloud game servers realms create agones-blog --time-zone EST --location us-central1
Create request issued for: [agones-blog]
Waiting for operation [projects/gcp-prime/locations/us-central1/operations/operation-1598980635305-5ae43b0c52589-34a097b6-d0659fc7] to c
omplete...done.
Created realm [agones-blog].
</code></pre>
<pre><code>▶ gcloud game servers clusters create agones-blog --realm=agones-blog --gke-cluster locations/us-central1/clusters/agones-blog --namespace=default --location us-central1 --no-dry-run
Create request issued for: [agones-blog]
Waiting for [operation-1598980727087-5ae43b63da1ee-88b19318-22a70d4f] to finish...done.
Created game server cluster: [agones-blog]
</code></pre>
<p>第一个命令创建领域，第二个命令将运行Agones的集群连接到该领域。</p>
<p>现在我们已经在一个领域中有了一个集群，下一步是创建一个部署。部署基本上是一组配置的容器，这些配置将描述一组游戏服务器。因此，我们创建部署，然后在其中创建配置:</p>
<pre><code>▶ gcloud game servers deployments create agones-blog
Create request issued for: [agones-blog]
Waiting for operation [projects/gcp-prime/locations/global/operations/operation-1598980944523-5ae43c3336ffd-4eb7fce4-fd872d08] to complete...done.
Created deployment [agones-blog].
</code></pre>
<pre><code>▶ gcloud game servers configs create config-1 --deployment agones-blog --fleet-configs-file fleet_configs.yaml
Create request issued for: [config-1]
Waiting for operation [projects/gcp-prime/locations/global/operations/operation-1598981023478-5ae43c7e83334-58008b9c-8df141c0] to complete...done.
Created game server config [config-1].
</code></pre>
<p>注意，在创建配置时，我指定了一个包含车队规范的yaml文件。车队规范看起来很像我们之前部署的gameserver规范，但是具有模板和副本字段:</p>
<pre><code>- name: fleet-spec-1
  fleetSpec:
    replicas: 2
    template:
      metadata:
        labels:
          foo: bar
      spec:
        ports:
        - name: default
          portPolicy: Dynamic
          containerPort: 7654
        template:
          spec:
            containers:
            - name: simple-udp
              image: gcr.io/agones-images/udp-server:0.17
</code></pre>
<p>这表明我们希望创建两个游戏服务器，并保持副本数量为2。如果gameserver规范类似于pod规范，那么舰队就很像Kubernetes部署。</p>
<p>最后要做的事情是将该部署部署到领域中的集群。</p>
<pre><code>▶ gcloud game servers deployments update-rollout agones-blog --default-config config-1 --no-dry-run
Update rollout request issued for: [agones-blog]
Waiting for [operation-1598981253616-5ae43d59fd30b-b841d131-f1822e0c] to finish...done.
Updated rollout for: [agones-blog]
createTime: '2020-09-01T17:22:24.587136253Z'
defaultGameServerConfig: projects/gcp-prime/locations/global/gameServerDeployments/agones-blog/configs/config-1
etag: fHXlfY2MivvPraKyPJEseJF5SqjaBfUrnaWMGT1aCb8
name: projects/gcp-prime/locations/global/gameServerDeployments/agones-blog/rollout
updateTime: '2020-09-01T17:22:25.547699385Z'
</code></pre>
<p>完成后，我们看到在我们的集群中部署了agones车队，配备了我们要求的两台游戏服务器:</p>
<pre><code>▶ kubectl get fleet
NAME                         SCHEDULING   DESIRED   CURRENT
fleet-agones-blog-config-1   Packed       2         2
</code></pre>
<pre><code>▶ kubectl get gameserver
NAME                                     STATE   ADDRESS         PORT
fleet-agones-blog-config-1-st55c-8gbd2   Ready   34.123.40.127   7212
fleet-agones-blog-config-1-st55c-rnxjh   Ready   34.123.40.127   7839
</code></pre>
<h3>为什么使用GCGS？</h3>
<p>到目前为止，看起来你可以使用Agones CRD将舰队部署到你的集群，这是完全正确的。GCGS的真正优势在于这些车队的多集群管理。</p>
<p>在进一步的探索中，我启动了另一个集群，安装了Agones，并将该集群添加到领域中。当我添加第二个集群时，我看到舰队也被部署到新的集群。这告诉我，集群现在由GCGS集中管理。我可以在领域中随意添加和删除集群，并且我的游戏服务器部署保持不变。这是一个非常强大的概念，它将使管理游戏服务器的大规模部署变得更加容易。</p>
<h2><strong>游戏服务器分配</strong></h2>
<p>到目前为止，我们已经看到了如何使用Agones + GCGS将游戏服务器部署到多个集群，但是我们实际上如何使用这些游戏服务器呢？我们知道每个游戏服务器都处于<span> <code>Ready</code> </span>状态，并且每个游戏服务器都可以在指定的端口和IP地址上接收UDP流量。现在让我们探索另一个强大的Agones概念:分配。</p>
<p>您可能已经注意到，其中一个控制平面部署名为<span> <code>agones-allocator.</code> </span>默认情况下，Helm chart会部署这个控制平面和一个相应的服务，但是在您可以使用它之前，它需要进一步的配置。分配服务的设置超出了本文的范围，但是在<strong> <a href="https://cloud.google.com/game-servers/docs/how-to/configuring-multicluster-allocation" target="_blank" rel="noopener">高级Agones文档中有详细介绍。</a> </strong></p>
<p>一旦配置了分配器服务，您就可以使用mTLS和gRPC向分配器发出请求。该请求可以指定选择器，该选择器将通过标签来限制游戏服务器的选择。您得到的响应是一个IP地址和一个游戏服务器的端口。真正酷的部分是这个游戏服务器的状态现在在Kubernetes API中变成了<span> <code>Allocated</code> </span>。这意味着不允许分配器服务再次分配那个游戏服务器，并且在节点耗尽的情况下，这个游戏服务器不能再被Kubernetes关闭。实际上，这种pod现在是一种长寿服务，只要它还在使用，Agones和Kubernetes就会努力让它保持活力。</p>
<p>此外，GCGS还可以设置多集群分配，这样，每当您向领域中的集群发出分配请求时，您都可以被分配到该领域中任何集群中的任何可用游戏服务器。这是涵盖在<a href="https://cloud.google.com/game-servers/docs/how-to/configuring-multicluster-allocation"/><a href="https://cloud.google.com/game-servers/docs/how-to/configuring-multicluster-allocation" target="_blank" rel="noopener">【GCGS】文档中的</a>。</p>
<h2><strong>总之</strong></h2>
<p>Agones是一个开源平台，提供CRDs和一个控制器，用于在Kubernetes中运行游戏服务器。运行起来很简单，文档也很棒。添加Google云游戏服务器可以让你从一个中心点管理多个运行Agones的集群，并使跨所有集群部署游戏服务器变得更加简单。</p>
<p>在我探索这些产品的过程中，我越来越对它们让运行游戏服务器变得更容易的潜力感到兴奋。我遇到的障碍很小，Agones public Slack中的谷歌员工总是乐于助人，提供丰富的信息。我很少探索一个新的谷歌产品(当我第一次遇到它时，它还处于测试阶段)并有这种很好的体验。向在Agones工作的团队大声欢呼。</p>
<p><span class="hs-cta-wrapper" id="hs-cta-wrapper-4f92c7e1-1646-4985-9a0a-b1091903dddb"><span class="hs-cta-node hs-cta-4f92c7e1-1646-4985-9a0a-b1091903dddb" id="hs-cta-4f92c7e1-1646-4985-9a0a-b1091903dddb"><a href="https://cta-redirect.hubspot.com/cta/redirect/2184645/4f92c7e1-1646-4985-9a0a-b1091903dddb"><img class="hs-cta-img" id="hs-cta-img-4f92c7e1-1646-4985-9a0a-b1091903dddb" src="../Images/b53e4ee22b6ef19bc06a035649ea1dc6.png" alt="Free Download: Kubernetes Best Practices Whitepaper" data-original-src="https://no-cache.hubspot.com/cta/default/2184645/4f92c7e1-1646-4985-9a0a-b1091903dddb.png"/></a></span>T6】</span></p></span></div>    
</body>
</html>