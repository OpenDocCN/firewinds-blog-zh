<html>
<head>
<title>How to Kubernetes: Use Conftest to Audit Infrastructure-As-Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何Kubernetes:使用Conftest审计基础设施即代码</h1>
<blockquote>原文：<a href="https://www.fairwinds.com/blog/how-to-kubernetes-use-conftest-to-audit-infrastructure-as-code#2022-12-05">https://www.fairwinds.com/blog/how-to-kubernetes-use-conftest-to-audit-infrastructure-as-code#2022-12-05</a></blockquote><div><span id="hs_cos_wrapper_post_body" class="hs_cos_wrapper hs_cos_wrapper_meta_field hs_cos_wrapper_type_rich_text" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p>在<span> </span> Fairwinds，我们在我们的开源产品<span> </span> <a href="https://github.com/fairwindsops/polaris" title="Fairwinds Polaris" rel="noopener" target="_blank"> Polaris </a>以及我们的SaaS产品<span/><a href="/insights" title="Fairwinds Insights" rel="noopener">fair winds Insights</a>中利用OPA ( <a href="https://www.openpolicyagent.org/" title="Open Policy Agent" rel="noopener" target="_blank">开放策略代理</a>)。随着我们的开发团队实现这些功能，我开始思考我们可以利用Fairwinds的OPA来增强我们Kubernetes环境的可靠性和安全性的其他方法。</p>

<p>与此同时，我试图想出一种方法来更好地审计我们的许多基础设施即代码库。对于我们的每个客户，都有一个回购协议，我们为该客户所做的一切都会进入回购协议。可以想象，跨客户的标准会逐渐过时，我们需要知道他们什么时候会过时。目前我们有一个基于Python的内部解决方案来做这件事，但是它变得有点笨拙和过时了。计划是重写它，但EJ(我们的前首席技术官)有一个更好的主意:“为什么我们不使用OPA？”我的回应当然是facepalm。我怎么没想到呢？因此，我四处查看了OPA资料库，重温了我对<span> </span> <span> <code>rego,</code> </span>的一点点知识，并整理了一份概念证明。我需要一种运行和测试策略的方法，所以我更新了我的版本<span/><a href="https://github.com/open-policy-agent/conftest" title="conftest" rel="noopener" target="_blank">conftest</a><span/>，事实证明，它被设计来做我需要做的事情:审计配置文件。</p>
<h2>撰写政策</h2>
<p>下一步，写保单，是最难的部分。作为一个经常使用Python和Go等语言进行开发的人，这比我想象的要困难得多。<span> </span> <span> <code>Rego</code> </span> <span> </span>不是一种编程语言，而是一种查询语言，这意味着我需要思考这一切的方式与我通常的思考方式不太一样。一旦你进入了它的最佳状态，它就会变得非常强大，但这花了我相当长的时间。我决定从检查我们正在使用的Terraform模块的版本开始，并将其与批准的模块列表进行比较。在野外有很好的例子，所以我能够找到这些例子并开始行动。我能写的最基本的策略是这样的:</p>
<pre><code>package terraform<br/><br/>import data<br/><br/>violation[{"msg": msg}] {<br/>    m := input.module[name]<br/>    source := m.source<br/>    not source == "git::https://github.com/FairwindsOps/terraform-vpc.git?ref=v5.0.1"<br/>    msg = sprintf("%s module version %s is out of date", [name, source])<br/>}</code></pre>
<p>第一行，<span> </span> <span> <code>package terraform,</code> </span>只是允许我将策略分成多个部分。最终，我要用一堆不同的模块来结束，比如<span> </span> <span> <code>terraform,</code> <code>kops,</code> <span>和</span> <code>kubernetes.</code> </span>当使用此策略与<span> <code>conftest,</code> </span>时，我们将使用<span><span><code>--namespace=terraform</code></span><span/>标志来定位terraform模块。策略的下一部分读入传递给它的terraform数据中的所有模块，并将每个模块与一个静态字符串进行比较。如果有匹配，则返回<span> </span> <span> <code>msg </code> </span>作为违规。<br/> <br/>这个政策是有作用的，但是并没有完全达到我们想要的效果。我们需要添加针对不同字符串检查不同模块名称的功能。这需要一个映射变量，我们可以用它来指定多个模块名，我们称它为<span> </span> <span> <code>module_allowlist.</code> </span>，这给了我们以下内容:</span></p>
<pre><code>package terraform<br/><br/>import data<br/><br/>module_allowlist = {<br/>    "vpc": "git::https://github.com/FairwindsOps/terraform-vpc.git?ref=v5.0.1",<br/>    "bastion": "git::https://github.com/fairwindsops/terraform-bastion.git//aws?ref=aws-v0.6.0",<br/>}<br/><br/>violation[{"msg": msg}] {<br/>    m := input.module[name]<br/>    source = m.source<br/>    not source == module_allowlist[name]<br/>    msg = sprintf("%s module version %s is out of date", [name, source])<br/>}<br/></code></pre>
<p><br/>这里我们将实际模块源与<span> </span> <span> <code>module_allowlist</code> </span> <span> </span>图中的对应源进行比较。这样更好，但是我们有另一个问题:有多个允许版本的模块怎么办？上面的<span/><span><code>bastion</code></span><span/>模块就是一个很好的例子；我们期待不同版本的<span/><span><code>bastion</code></span><span/>取决于你使用的云提供商。让我们将地图格式更改为<span> </span> <span> <code>module_name: [list of possible versions].</code> </span>新的策略看起来是这样的:</p>
<pre><code>package terraform<br/><br/>import data<br/><br/>module_allowlist = {<br/>    "vpc": ["git::https://github.com/FairwindsOps/terraform-vpc.git?ref=v5.0.1"],<br/>    "bastion": [<br/>        "git::https://github.com/fairwindsops/terraform-bastion.git//aws?ref=aws-v0.6.0",<br/>        "git::https://github.com/fairwindsops/terraform-bastion.git//gcp?ref=gcp-v0.1.1",<br/>    ],<br/>}<br/><br/>violation[{<br/>    "msg": msg,<br/>}] {<br/>    m := input.module[name]<br/>    source = m.source<br/>    not contains(module_allowlist[name], source)<br/>    msg = sprintf("%s module version %s is out of date", [name, source])<br/>}<br/><br/>contains(sources, elem) {<br/>    source := sources[_]<br/>    source == elem<br/>}<br/></code></pre>
<p><br/>现在我们有了一个可能版本的列表，我们引入一个函数<span> </span> <span> <code>contains</code> </span> <span> </span>来检查我们的源模块是否在该模块允许的源列表中。这意味着通过用更多的信息填充映射，我们可以检查所有种类的模块版本，而不仅仅是一个。<br/> <br/>我们最不希望这个策略在将结果输出为JSON时返回更多的数据。我们的目标是能够存储、呈现或分析这些数据，因此它有助于添加更多的细节。幸运的是，机制已经存在，我们只需要利用它。<br/> <br/>这个文件的最终产品，叫做<span> </span> <span> <code>terraform.reg:</code> </span></p>
<pre><code>package terraform<br/><br/>import data<br/><br/>module_allowlist = {<br/>        "vpc": ["git::https://github.com/FairwindsOps/terraform-vpc.git?ref=v5.0.1"],<br/>        "bastion": [<br/>                "git::https://github.com/fairwindsops/terraform-bastion.git//aws?ref=aws-v0.6.0",<br/>                "git::https://github.com/fairwindsops/terraform-bastion.git//gcp?ref=gcp-v0.1.1",<br/>        ],<br/>}<br/><br/>violation[{<br/>        "msg": msg,<br/>        "family": "terraform",<br/>        "check": "module version",<br/>        "module": name,<br/>}] {<br/>        m := input.module[name]<br/>        source = m.source<br/>        not contains(module_allowlist[name], source)<br/>        msg = sprintf("%s module version %s is out of date", [name, source])<br/>}<br/><br/>contains(sources, elem) {<br/>        source := sources[_]<br/>        source == elem<br/>}<br/></code></pre>
<p><br/> <br/>在违例的定义中，我们增加了几条数据:</p>
<ul>
<li>
<p><code>"msg"</code><span/>——变量 <code>msg</code>中我要返回的消息。这已经到位了</p>
</li>
<li>
<p><code>"family"</code> <span> </span> -表示数据来源的字符串，本例中为<span> </span> <span> <code>terraform</code> </span></p>
</li>
<li>
<p><code>"check"</code><span/>——我希望能够说出我在检查什么。在这里，是<span> </span> <span> <code>"module version"</code> </span></p>
</li>
<li>
<p><code>"module"</code> <span> </span> -这将通过变量<span> </span> <code>name</code>设置为触发违规的模块的名称</p>
</li>
</ul>
<p>最终结果是我们现在可以运行:</p>
<pre><code>conftest test &lt;path-to-terraform-file(s)&gt; --policy terraform.rego -ojson --namespace  terraform</code></pre>
<p>得到这样的输出:</p>
<pre><code>[<br/>  {<br/>    "<span>filename</span>": <span>"bastion.tf"</span>,<br/>    "<span>namespace</span>": <span>"terraform"</span>,<br/>    "<span>successes</span>": <span>0</span>,<br/>    "<span>failures</span>": <span>[<br/>      {<br/>        "msg": "bastion module version git::https://github.com/fairwindsops/terraform-bastion.git//aws?ref=aws-v0.5.0 is out of date",<br/>        "metadata": {<br/>          "check": "module version",<br/>          "family": "terraform",<br/>          "module": "bastion"<br/>        }<br/>      }<br/>    ]<br/>  </span>}<br/>]<br/></code></pre>
<p><br/>或者，如果您喜欢在CLI上查看结果，请放下<span> </span> <span> <code>-o json</code> </span> <span> </span>标志:</p>
<pre><code>FAIL - bastion.tf - terraform - bastion module version git::https://github.com/fairwindsops/terraform-bastion.git//aws?ref=aws-v0.5.0 is out of date<br/></code></pre>
<h2>添加测试</h2>
<p><span> <code>rego</code> </span> <span> </span>还有另一个我想利用的非常棒的功能:<span> </span>单元测试。这对于制定政策以及长期维护政策来说是非常强大的。为了测试这个功能，我为上一节中的<span/><span><code>terraform.rego</code></span><span/>策略编写了一个测试。下面是我新的<span/><span><code>terraform_test.rego</code></span><span/>文件:</p>
<pre><code>package terraform<br/><br/>empty(value) {<br/>    count(value) == 0<br/>}<br/><br/>no_violations {<br/>    empty(violation)<br/>}<br/><br/>test_module_source {<br/>    violation[{"check": "module version", "family": "terraform", "module": "bastion", "msg": "bastion module version git::https://github.com/fairwindsops/terraform-bastion.git//aws?ref=aws-v0.0.0 is out of date"}] with input as {"module": {"bastion": {"source": "git::https://github.com/fairwindsops/terraform-bastion.git//aws?ref=aws-v0.0.0"}}}<br/>}<br/></code></pre>
<p>本质上，如果我传入一个名为<span> </span> <span> <code>bastion</code> </span> <span> </span>的模块，而这个模块的版本不在我的列表中，我认为会有一个违例。该测试可以使用命令<span> </span> <span> <code>conftest verify.</code> </span>运行</p>
<h2>结论</h2>
<p>现在，我有能力编写一整套审计策略，针对我们所有的基础设施代码运行它，并生成结构化的JSON数据，这将允许我分析结果并报告发现。更好的是，由于<span/><a href="https://www.fairwinds.com/insights" title="Fairwinds Insights">fair winds Insights</a><span/>支持OPA，我可以插入这些策略，让Insights为我收集和管理这些数据。这可能会成为我们工作流程中不可或缺的一部分，使我们的服务代表能够更好地管理许多客户，并在此过程中收集有用的信息。</p>
<p><span class="hs-cta-wrapper" id="hs-cta-wrapper-34aa4987-a1f9-438a-a145-d7d82d5c479a"><span class="hs-cta-node hs-cta-34aa4987-a1f9-438a-a145-d7d82d5c479a" id="hs-cta-34aa4987-a1f9-438a-a145-d7d82d5c479a"><a href="https://cta-redirect.hubspot.com/cta/redirect/2184645/34aa4987-a1f9-438a-a145-d7d82d5c479a"><img class="hs-cta-img" id="hs-cta-img-34aa4987-a1f9-438a-a145-d7d82d5c479a" src="../Images/7c86296320eb01b215d8e2755e9c5b9d.png" alt="Use Fairwinds Insights for Free Security, Cost and Developer Enablement In One" data-original-src="https://no-cache.hubspot.com/cta/default/2184645/34aa4987-a1f9-438a-a145-d7d82d5c479a.png"/></a></span>T6】</span></p></span></div>    
</body>
</html>