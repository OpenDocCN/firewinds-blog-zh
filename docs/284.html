<html>
<head>
<title>Now Available: Fairwinds Polaris 4.0 — Policy for Kubernetes Resources</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>现已发布:fair winds Polaris 4.0—Kubernetes资源政策</h1>
<blockquote>原文：<a href="https://www.fairwinds.com/blog/fairwinds-polaris-4.0-policy-kubernetes-resources#2022-12-05">https://www.fairwinds.com/blog/fairwinds-polaris-4.0-policy-kubernetes-resources#2022-12-05</a></blockquote><div><span id="hs_cos_wrapper_post_body" class="hs_cos_wrapper hs_cos_wrapper_meta_field hs_cos_wrapper_type_rich_text" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p>Fairwinds Polaris已经到了4.0版本，有一些令人敬畏的新功能！(对于那些保持分数的人来说，由于一些<a href="https://github.com/FairwindsOps/polaris/blob/master/docs/changelog.md" rel="noopener" target="_blank">突破性的变化</a>，我们很快跳过了2.0和3.0)。</p>
 
<p>我们最初编写Polaris是为了帮助Kubernetes用户在部署工作负载时避免常见的陷阱。在为几十个组织管理数百个集群的过程中，Fairwinds SRE团队不断看到相同的错误:资源请求和限制未设置，活跃度和就绪性探测被忽略，容器请求完全不必要的安全权限。这些肯定会造成令人头疼的问题——从停机到成本超支，甚至是安全漏洞。我们将Polaris视为将我们所有的战斗伤痕编码到一个单一的配置验证器中的一种方式，这将使整个Kubernetes社区受益。</p>
<p>随着Polaris从仪表板发展为准入控制器(以防止这些资源进入集群)，现在又发展为CI工具(以防止它们进入基础架构代码报告)，我们收到了越来越多的实施新检查的请求，例如入口是否使用TLS，或者部署是否有PodDisruptionBudget。</p>
<p>为了更好地满足这些需求，我们在<a href="https://polaris.docs.fairwinds.com/customization/custom-checks/" rel="noopener" target="_blank">自定义检查功能</a>中实现了三个主要的新特性:</p>
<ul>
<li>检查非工作负载类型的能力，如入口、服务和集群角色</li>
<li>引用模式中其他字段的能力</li>
<li>交叉检查资源的能力，例如，确保部署有相应的PodDisruptionBudget</li>
</ul>
<h2>支持非工作负载类型</h2>
<p>Polaris最初设计用于检查集群中运行的工作负载，例如，Pods和任何创建Pods的东西，如部署、CronJobs和StatefulSets。这是我们看到最痛苦的错误发生的地方，也是一个自然的起点。</p>
<p>然而，当团队开始部署Polaris并看到控制工作负载配置的价值时，他们看到了检查其他Kubernetes资源的自然潜力。例如，一些公司有关于入口使用TLS的内部或监管要求，并希望检查每个入口对象是否启用了TLS。</p>
<p>添加对新资源类型的支持需要一点重构。最初我们只需要检索一组固定的资源类型，所以我们能够使用类型良好的<a href="https://github.com/kubernetes/client-go" rel="noopener" target="_blank"> client-go </a>函数，比如<code>Deployments(``""``).List()</code>。但是支持任意类型需要我们利用<a href="https://godoc.org/k8s.io/client-go/dynamic" rel="noopener" target="_blank">动态客户端</a>，由于缺乏类型安全，这需要更多的关注。</p>
<p>为了让您开始，我们已经实现了一个<a href="https://github.com/FairwindsOps/polaris/blob/master/checks/tlsSettingsMissing.yaml" rel="noopener" target="_blank">检查来确保入口对象正在使用TLS </a>。如果您有其他想法，您可以将它们添加到您自己的Polaris配置中，或者甚至更好，打开一个PR将它们贡献回核心回购！</p>
<h2>支持自我参考</h2>
<p>JSON Schema是一种非常直观和强大的验证资源的方法，但是与更具编程性的框架(比如OPA)相比，它有一个缺点:JSON Schema更简单，但是它不能做OPA能做的一些更复杂的事情。</p>
<p>特别是，北极星2.0没有自我参照的方法。例如，您可能想要检查的一件事是<code>app.kubernetes.io/name</code>标签是否与<code>metadata.name</code>字段匹配。OPA可以很容易地做到这一点:</p>
<pre><code><span>package</span> fairwinds <br/><br/>
labelMustMatchName[result] { <br/>
  input.metadata.labels["<span>app.kubernetes.io/name</span>"] <span>!=</span> metadata.name <br/>
  result <span>:=</span> { <br/>
    "<span>description"<span>:</span> "label app.kubernetes.io/name must match metadata.name</span>", <br/>
  } <br/>
}
</code></pre>
<p>为了在Polaris中支持这一点，我们在JSON模式支持中添加了一些基本的模板:</p>
<pre><code>successMessage<span>:</span> Label app.kubernetes.io<span>/</span>name matches metadata.name
failureMessage<span>:</span> Label app.kubernetes.io<span>/</span>name must match metadata.name
kinds<span>:</span>
<span>-</span> Deployment
schema<span>:</span>
  <span>'$schema'</span><span>:</span> http<span>://</span>json<span>-</span>schema.org<span>/</span>draft<span>-</span><span>07</span><span>/</span>schema
  type<span>:</span> object
  properties<span>:</span>
    metadata<span>:</span>
      type<span>:</span> object
      properties<span>:</span>
        labels<span>:</span>
          type<span>:</span> object
          required<span>:</span> [<span>"app.kubernetes.io/name"</span>]
          properties<span>:</span>
            app.kubernetes.io<span>/</span>name<span>:</span><span>"{{ metadata.name }}</span>"</code></pre>
<p>虽然这仍然没有给<em>OPA所提供的所有</em>灵活性，但它允许我们处理Polaris 2.0无法解决的大多数用例。</p>
<h2>支持跨资源引用</h2>
<p>我们收到的第一个也是最常见的请求之一是能够检查部署是否有关联的PodDisruptionBudget或HorizontalPodAutoscaler。这些资源对于确保部署适当扩展至关重要，并且是大多数组织的部署策略的重要组成部分，因此想要检查这些资源是很自然的事情。</p>
<p>这里的挑战是Polaris检查是使用JSON模式定义的。这对于单个资源来说非常好——我们只是根据检查的模式验证Kubernetes API返回的JSON。但是为了支持交叉引用，我们必须做一些事情:</p>
<ul>
<li>提供一种访问非控制器资源的方法(上面的✅)</li>
<li>将某些字段模板化，例如，可以在poddisruptionbudget(上面的✅)中断言部署的名称</li>
<li>提供在同一检查中定义多个模式的语法</li>
</ul>
<p>事不宜迟，下面是我们创建的检查，以确保PDB附加到所有部署，它使用所有三个新功能:</p>
<pre><code>successMessage<span>:</span> <span>A</span> PodDisruptionBudget is attached
failureMessage<span>:</span> Should have a PodDisruptionBudget
kinds<span>:</span>
<span>-</span> Deployment
schema<span>:</span>
  <span>'$schema'</span><span>:</span> http<span>://</span>json<span>-</span>schema.org<span>/</span>draft<span>-</span><span>07</span><span>/</span>schema
  type<span>:</span> object
  properties<span>:</span>
    metadata<span>:</span>
      type<span>:</span> object
      properties<span>:</span>
        labels<span>:</span>
          type<span>:</span> object
          required<span>:</span> [<span>"app.kubernetes.io/name"</span>]
          properties<span>:</span>
            app.kubernetes.io/name<span>:</span> \{\{ metadata.name \}\}
additionalSchemas<span>:</span>
  PodDisruptionBudget<span>:</span>
    <span>'$schema'</span><span>:</span> http<span>://</span>json-schema.org<span>/</span>draft<span>-</span><span>07</span><span>/</span>schema
    type<span>:</span> object
    properties<span>:</span>
      metadata<span>:</span>
        type<span>:</span> object
        properties<span>:</span>
          name<span>:</span>
            type<span>:</span> string
            <span>const</span><span>:</span> {{ metadata.name }}<span>-</span>pdb
      spec<span>:</span>
        type<span>:</span> object
        properties<span>:</span>
          selector<span>:</span>
            type<span>:</span> object
            properties<span>:</span>
              matchLabels<span>:</span>
                type<span>:</span> object
                properties<span>:</span>
                  app.kubernetes.io<span>/</span>name<span>:</span>
                    type<span>:</span> string
                    pattern<span>:</span> {{ metadata.name }}</code></pre>
<p>这里需要注意一些事情:</p>
<p>首先，<code>kinds</code>字段告诉Polaris将这个检查与哪些资源相关联。也就是说，如果上述检查失败，您将在相关部署旁边看到一个❌(而不是在PDB旁边)。</p>
<p>接下来，<code>schema</code>域像往常一样工作，检查主资源。</p>
<p>最后，<code>additionalSchemas</code>字段是从Kind到JSON模式的映射。在上面的检查中，Polaris将检查同一名称空间中的所有pdb，并试图找到一个与模式匹配的pdb。如果它没有发现任何东西，检查就会失败。</p>
<h2>结论</h2>
<p>我们对最新发布的北极星和我们增加的新功能感到兴奋。如今，北极星拥有超过10，000名用户，涵盖所有行业。如果您有兴趣管理整个集群舰队的北极星，跨团队合作，或随着时间的推移跟踪调查结果，请查看我们的持续Kubernetes安全监控和治理平台<a href="/insights" rel="noopener" target="_blank"> Fairwinds Insights </a>。</p>
<p>我们也希望<a href="/polaris-frequently-asked-questions" rel="noopener"> Polaris </a>用户加入我们新的<a href="/open-source-software-user-group" rel="noopener" target="_blank"> Fairwinds开源软件用户组</a>。我们对您对Polaris的贡献感到非常兴奋，并共同努力验证和实施Kubernetes部署。</p>
<p><span class="hs-cta-wrapper" id="hs-cta-wrapper-34aa4987-a1f9-438a-a145-d7d82d5c479a"><span class="hs-cta-node hs-cta-34aa4987-a1f9-438a-a145-d7d82d5c479a" id="hs-cta-34aa4987-a1f9-438a-a145-d7d82d5c479a"><a href="https://cta-redirect.hubspot.com/cta/redirect/2184645/34aa4987-a1f9-438a-a145-d7d82d5c479a"><img class="hs-cta-img" id="hs-cta-img-34aa4987-a1f9-438a-a145-d7d82d5c479a" src="../Images/7c86296320eb01b215d8e2755e9c5b9d.png" alt="Use Fairwinds Insights for Free Security, Cost and Developer Enablement In One" data-original-src="https://no-cache.hubspot.com/cta/default/2184645/34aa4987-a1f9-438a-a145-d7d82d5c479a.png"/></a></span>T6】</span></p></span></div>    
</body>
</html>