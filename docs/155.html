<html>
<head>
<title>How to Deploy a Multi-Tier Web Application with Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用Kubernetes部署多层Web应用程序</h1>
<blockquote>原文：<a href="https://www.fairwinds.com/blog/how-to-deploy-multi-tiered-web-application-with-kubernetes#2023-01-20">https://www.fairwinds.com/blog/how-to-deploy-multi-tiered-web-application-with-kubernetes#2023-01-20</a></blockquote><div><span id="hs_cos_wrapper_post_body" class="hs_cos_wrapper hs_cos_wrapper_meta_field hs_cos_wrapper_type_rich_text" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p>在Kubernetes系列的最后一篇介绍中，我们将带您了解如何部署多层web应用程序。webapp是一个带有Redis后端的关键值存储和检索服务。(阅读Kubernetes解决的<a href="/blog/what-problems-does-kubernetes-solve" rel=" noopener">问题</a>、<a href="/blog/getting-started-with-kubernetes-architecture-basics-definitions" rel=" noopener">架构和定义</a>或<a href="/blog/how-to-build-a-kubernetes-cluster-in-gke" rel=" noopener">在GKE建立K8S集群</a>)。</p>

<p>下面是我们将部署的内容的简要概述:</p>
<p><img src="../Images/5cdc36ead20589734494f5da1e844196.png" alt="Fairwinds Multi-tiered web application with Kubernetes diagram" srcset="https://www.fairwinds.com/hs-fs/hubfs/Fairwinds%20Multi-tiered%20web%20application%20with%20Kubernetes%20diagram.png?width=418&amp;name=Fairwinds%20Multi-tiered%20web%20application%20with%20Kubernetes%20diagram.png 418w, https://www.fairwinds.com/hs-fs/hubfs/Fairwinds%20Multi-tiered%20web%20application%20with%20Kubernetes%20diagram.png?width=836&amp;name=Fairwinds%20Multi-tiered%20web%20application%20with%20Kubernetes%20diagram.png 836w, https://www.fairwinds.com/hs-fs/hubfs/Fairwinds%20Multi-tiered%20web%20application%20with%20Kubernetes%20diagram.png?width=1254&amp;name=Fairwinds%20Multi-tiered%20web%20application%20with%20Kubernetes%20diagram.png 1254w, https://www.fairwinds.com/hs-fs/hubfs/Fairwinds%20Multi-tiered%20web%20application%20with%20Kubernetes%20diagram.png?width=1672&amp;name=Fairwinds%20Multi-tiered%20web%20application%20with%20Kubernetes%20diagram.png 1672w, https://www.fairwinds.com/hs-fs/hubfs/Fairwinds%20Multi-tiered%20web%20application%20with%20Kubernetes%20diagram.png?width=2090&amp;name=Fairwinds%20Multi-tiered%20web%20application%20with%20Kubernetes%20diagram.png 2090w, https://www.fairwinds.com/hs-fs/hubfs/Fairwinds%20Multi-tiered%20web%20application%20with%20Kubernetes%20diagram.png?width=2508&amp;name=Fairwinds%20Multi-tiered%20web%20application%20with%20Kubernetes%20diagram.png 2508w" sizes="(max-width: 836px) 100vw, 836px" data-original-src="https://www.fairwinds.com/hs-fs/hubfs/Fairwinds%20Multi-tiered%20web%20application%20with%20Kubernetes%20diagram.png?width=836&amp;name=Fairwinds%20Multi-tiered%20web%20application%20with%20Kubernetes%20diagram.png"/></p>
<p>我们已经准备了一个<a href="https://github.com/FairwindsOps/k8s-workshop"> GitHub存储库</a>，您可以用所有库本内特存储库、各种文档和Fairwinds用于研讨会的代码进行克隆。</p>
<p>转到Git &gt;克隆或下载&gt;复制URL。</p>
<p><img src="../Images/a8608643156f03c4015b821d5eba69bd.png" alt="Fairwinds GitHub k8s-workshop" srcset="https://www.fairwinds.com/hs-fs/hubfs/Fairwinds%20GitHub%20k8s-workshop.png?width=488&amp;name=Fairwinds%20GitHub%20k8s-workshop.png 488w, https://www.fairwinds.com/hs-fs/hubfs/Fairwinds%20GitHub%20k8s-workshop.png?width=975&amp;name=Fairwinds%20GitHub%20k8s-workshop.png 975w, https://www.fairwinds.com/hs-fs/hubfs/Fairwinds%20GitHub%20k8s-workshop.png?width=1463&amp;name=Fairwinds%20GitHub%20k8s-workshop.png 1463w, https://www.fairwinds.com/hs-fs/hubfs/Fairwinds%20GitHub%20k8s-workshop.png?width=1950&amp;name=Fairwinds%20GitHub%20k8s-workshop.png 1950w, https://www.fairwinds.com/hs-fs/hubfs/Fairwinds%20GitHub%20k8s-workshop.png?width=2438&amp;name=Fairwinds%20GitHub%20k8s-workshop.png 2438w, https://www.fairwinds.com/hs-fs/hubfs/Fairwinds%20GitHub%20k8s-workshop.png?width=2925&amp;name=Fairwinds%20GitHub%20k8s-workshop.png 2925w" sizes="(max-width: 975px) 100vw, 975px" data-original-src="https://www.fairwinds.com/hs-fs/hubfs/Fairwinds%20GitHub%20k8s-workshop.png?width=975&amp;name=Fairwinds%20GitHub%20k8s-workshop.png"/></p>
<p>你需要一个Kubernetes集群。你可以看看我们的博客<a href="/blog/how-to-build-a-kubernetes-cluster-in-gke" rel=" noopener">如何用GKE </a>构建一个Kubernetes集群。在GKE，打开您的云shell终端窗口，然后运行命令:</p>
<p><code>git clone <a href="https://github.com/FairwindsOps/k8s-workshop.git" rel=" noopener">https://github.com/FairwindsOps/k8s-workshop.git</a></code></p>
<p>这是一个相对较小的项目，所以会很快拉下来。</p>
<p>在存储库中，您可以找到自述文件、装配所需文件夹、完整文件夹、图像文件夹和istio文件夹。在这篇博客中，除了自述文件和完整的文件夹之外，你可以忽略所有的内容。自述文件中提供了两种途径。我们将把重点放在基本轨道上，但是如果你想深入研究在Kubernetes上部署应用程序时可能出现的问题，你可以回头看看kub assembly required版本。它为Kubernetes YAML提供了更多的细微差别，允许您调试和测试运行kubectl命令的能力。</p>
<p>下面是我们将用来部署完整web应用程序的步骤。这个博客将部署一个损坏的应用程序，我们将修复Kubernetes YAML文档，以使部署成功。</p>
<h2>部署到Redis数据库</h2>
<p>在本次研讨会中，您将:</p>
<ul>
<li>为您的应用程序部署新的命名空间</li>
<li>将Redis服务器部署到新的名称空间中</li>
<li>查看您使用Kubernetes部署的对象(部署，pod)</li>
<li>通过kubectl从部署的资源中获取日志</li>
</ul>
<p>您首先需要提供一个名称空间。名称空间是一种分割和存储Kubernetes API中提供的对象的方式。您可以通过运行以下命令来检查现有的名称空间:</p>
<p><code>kubectl get namespace</code></p>
<pre><code>danielle@cloudshell:~ (trial-275916)$ kubectl get namespace
NAME              STATUS   AGE
default           Active   75m
kube-node-lease   Active   75m
kube-public       Active   75m
kube-system       Active   75m
</code></pre>
<p>在GKE，你可以看到四种现有的名称空间——默认、kube-节点租赁、kube-公共和kube-系统。我们将创建一个新的名称空间:</p>
<p><code>kubectl apply -f namespace.yml</code></p>
<p><span/><code>-f</code><span>标志表示您将把一个文件传递给</span> <code>kubectl</code> <span>，让它提交给Kubernetes API。</span></p>
<pre><code>danielle@cloudshell:~ (trial-275916)$ kubectl apply -f namespace.yml
namespace/k8s-workshop created
</code></pre>
<p>您可以运行get namespace命令来查看您创建了什么。</p>
<pre><code>danielle@cloudshell:~/k8s-workshop/complete (trial-275916)$ kubectl get namespaces
NAME              STATUS   AGE
default           Active   81m
k8s-workshop      Active   73s
kube-node-lease   Active   81m
kube-public       Active   81m
kube-system       Active   81m</code></pre>
<p>随着学习的深入，您将向Kubernetes API all in YAML定义应用和提交对象。我们将使用<code>kubectl</code>命令行工具获取文件，解析它们并提交给API。</p>
<h2>第一层Web应用程序:Redis</h2>
<p>现在，您将从存储webapp状态的有状态后端开始部署web应用程序的第一层。kubectl允许你获取一系列YAML文件，把它们放在一个文件夹中，然后对整个文件夹进行操作。它将提供文件夹下定义的所有资源和对象。这允许您创建一组对象和迷你YAML文件，而不是用一千行定义一切的单个YAML文件。您将首先推出这个多层web应用程序的后端层——一个HA Redis实现。要四处看看，可以跑<code>ls -l 01_redis/</code></p>
<pre><code>danielle@cloudshell:~/k8s-workshop/complete (trial-275916)$ ls -1 01_redis/
redis.networkpolicy.yml
redis-primary.deployment.yml
redis-primary.service.yml
redis-replica.deployment.yml
redis-replica.horizontal_pod_autoscaler.yml
redis-replica.service.yml</code></pre>
<p>这下面有一系列文件。</p>
<ul>
<li>
<p>部署文件定义了启动的pod的数量(更多信息请参考Kubernetes架构基础和定义)。</p>
</li>
<li>
<p>您将看到定义clusterIP服务的服务文件(clusterIP，因为您不想让Redis暴露给公共internet)。</p>
</li>
<li>
<p>这是一个HA Redis实施，因此您将拥有一个复制副本部署文件和一个复制副本水平pod自动缩放器(HPA)。autoscaler允许您根据部署中设置的资源请求自动扩展。</p>
</li>
<li>
<p>您还拥有一个可用于副本服务器的服务，这样主服务器就可以与副本服务器对话，还拥有一个用于redis的网络策略。</p>
</li>
</ul>
<p>您可以查看这些文件，看看定义是什么样子的。在文本编辑器中，打开redis-primary部署文件:</p>
<p><code>vim redis.primary.deployment.yml</code></p>
<p>您将看到一个API版本，一个种类(您在其中指定了您将提交的对象)，元数据，以及一个关于部署应该是什么样子的规范。</p>
<pre><code>apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: redis-primary
  namespace: k8s-workshop
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: redis
        role: primary
        tier: backend
    spec:
      containers:
      - name: redis
        image: gcr.io/google_containers/redis:e2e  # or just image: redis
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        ports:
        - containerPort: 6379 </code></pre>
<p>在这种情况下，您将调配一个副本(即一个单元是部署的一部分)。您将在template.spec中模板化您想要的规范。您还可以定义一组容器。在本例中，您将只有一个容器需要旋转。容器的名称是从Google容器注册表中提取的Redis。您还将发出一些附加到容器的资源请求——分配100个CPU份额、100 MB内存和网络，以公开redis默认的端口6379。您可以深入研究YAML定义，并尝试添加更多的容器或副本。</p>
<h2><strong>将YAML应用于集群</strong></h2>
<p>现在，您将把您的YAML定义应用到集群中。运行:</p>
<p><code>kubectl apply -f 01_redis/</code></p>
<p>这个命令检查了上面检查的所有文件，并为每个文件创建了对象。</p>
<pre><code>danielle@cloudshell:~/k8s-workshop/complete (trial-275916)$ kubectl apply -f 01_redis/
deployment.extensions/redis-primary created
service/redis-primary created
deployment.extensions/redis-replica created
horizontalpodautoscaler.autoscaling/redis-replica created
service/redis-replica created
networkpolicy.networking.k8s.io/redis created</code></pre>
<p>现在，您需要读取这些对象，并获取正在运行的数据。</p>
<p><code>kubectl -n k8s-workshop get pod</code></p>
<p>您将看到有两个pod在运行——一个Redis主服务器和一个副本服务器。</p>
<pre><code>NAME                             READY   STATUS    RESTARTS   AGE
redis-primary-684c84fc56-57brt   1/1     Running   0          75s
redis-replica-d64bd9565-zn7sg    1/1     Running   0          74s</code></pre>
<p>现在对部署采取相同的步骤:</p>
<p><code>kubectl -n k8s-workshop get deployments</code></p>
<p>您将看到有关您的部署的信息—Redis副本、Redis主服务器、所需的1计数、当前1、最新、可用内容以及pod的年龄。</p>
<pre><code>NAME            READY   UP-TO-DATE   AVAILABLE   AGE
redis-primary   1/1     1            1           2m37s
redis-replica   1/1     1            1           2m36s</code></pre>
<p>如果您正在进行滚动部署，您将在这里看到更多关于应用程序状态的有趣信息。</p>
<p>您还可以通过运行以下命令来查看服务:</p>
<p><code>kubectl -n k8s-workshop get services</code></p>
<p>在这里，您可以看到两个服务—主服务和副本服务。</p>
<pre><code>NAME            TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
redis-primary   ClusterIP   10.8.11.78           6379/TCP   5m35s
redis-replica   ClusterIP   10.8.4.228           6379/TCP   5m34s</code></pre>
<p>这两种服务都是集群IP服务(即仅在集群内部的IP上可用)。您还会看到IP和一些关于端口和年龄的信息。如果您想用一个命令进行总结，您可以运行:</p>
<p><code>kubectl -n k8s-workshop get deployments,pods,services</code></p>
<p>这允许您在单个图像中显示所有资源。</p>
<pre><code>NAME                                  READY   UP-TO-DATE   AVAILABLE   AGE
deployment.extensions/redis-primary   1/1     1            1           6m42s
deployment.extensions/redis-replica   1/1     1            1           6m41s
NAME                                 READY   STATUS    RESTARTS   AGE
pod/redis-primary-684c84fc56-57brt   1/1     Running   0          6m42s
pod/redis-replica-d64bd9565-zn7sg    1/1     Running   0          6m41s
NAME                    TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
service/redis-primary   ClusterIP   10.8.11.78           6379/TCP   6m42s
service/redis-replica   ClusterIP   10.8.4.228           6379/TCP   6m41s</code></pre>
<p>通过这些步骤，您现在应该可以在Kubernetes的<span> <code>k8s-workshop namespace</code> </span>中看到一个健康的redis主服务器和副本。</p>
<h2><strong> <span>部署Web App </span> </strong></h2>
<p>接下来，您将:</p>
<ul>
<li>将web应用程序部署到<span> <code>default</code> </span>名称空间(与我们在上面创建的名称空间不同)</li>
<li>观察云负载平衡器创建对web应用程序的外部访问</li>
<li>卷曲新部署的web应用程序以进行手动测试</li>
<li>查看web应用程序的日志</li>
<li>通过部署到正确的名称空间来修复损坏的web应用程序部署</li>
<li>再次卷曲web应用程序进行测试</li>
</ul>
<p>首先列出webapp目录<span> <code>ls -l 02_webapp/</code> </span>,看看它有没有类似于redis后端的文件。</p>
<pre><code>danielle@cloudshell:~/k8s-workshop/complete (trial-275916)$ ls -1 02_webapp/
app.configmap.yml
app.deployment.yml
app.horizontal_pod_autoscaler.yml
app.networkpolicy.yml
app.secret.yml
app.service.yml</code></pre>
<p>有两种新的对象类型:配置映射和机密。</p>
<ul>
<li>配置映射提供了将环境变量和静态文件导入pod的方法。如果您查看configmap YAML文件，您可以深入查看一系列分层的键。</li>
<li>秘密允许您存储和管理敏感信息，如密码、OAuth令牌和ssh密钥。</li>
</ul>
<p>要部署基本webapp:</p>
<p><span>T2<code>kubectl apply -f 02_webapp/</code></span></p>
<p>这将部署<code>02_webapp/</code>文件夹中的所有yaml定义。注意，我们<i>不是</i>在YAML的<code>metadata</code>中定义名称空间，所以它将默认为用<code>kubectl.</code>配置的默认名称空间</p>
<pre><code>danielle@cloudshell:~/k8s-workshop/complete (trial-275916)$ kubectl apply -f 02_webapp/
configmap/webapp created
deployment.extensions/webapp created
horizontalpodautoscaler.autoscaling/webapp created
networkpolicy.networking.k8s.io/app created
secret/webapp created
service/webapp created</code></pre>
<p>您可以通过运行<code>kubectl -n k8s-workshop get configmaps </code>来查看您创建并在部署中引用的配置图，您将看到没有找到任何资源。</p>
<pre><code>danielle@cloudshell:~/k8s-workshop/complete (trial-275916)$ kubectl -n k8s-workshop get configmaps
No resources found in k8s-workshop namespace.</code></pre>
<p>在这个有意的例子中，您将看到一个参数丢失的实例。每次部署或尝试读回信息时，您都要查看默认名称空间并指定<code>k8s-workshop</code>名称空间。</p>
<p>在这个例子中，<code>02_webapp/</code>实现被部署到默认的名称空间中。要检查这一点，请运行:</p>
<code>kubectl get configmaps</code>
<p>您将看到webapp configmap在那里，但是它被部署到了错误的名称空间。</p>
<pre><code>danielle@cloudshell:~/k8s-workshop/complete (trial-275916)$ kubectl get configmaps
NAME     DATA   AGE
webapp   2      4m8s</code></pre>
<p>您需要重新运行apply并指定名称空间。原因是如果您查看<code>01_redis</code>主部署，您指定了一个名称空间。如果您查看webapp的相同部署，您会看到在元数据下，您没有提供名称空间。</p>
<p>您需要使用kubectl delete <code>-f 02_webapp/</code>取消最后一次应用，以删除创建的对象并正确部署到k8s-workshop名称空间中。</p>
<pre><code>danielle@cloudshell:~/k8s-workshop/complete (trial-275916)$ kubectl delete -f 02_webapp/
configmap "webapp" deleted
deployment.extensions "webapp" deleted
horizontalpodautoscaler.autoscaling "webapp" deleted
networkpolicy.networking.k8s.io "app" deleted
secret "webapp" deleted
service "webapp" deleted</code></pre>
<p>现在，您将在正确的名称空间中应用程序。</p>
<code>kubectl apply -f 02_webapp/ --namespace k8s-workshop</code>
<p>这将覆盖未设置的<code>default</code>名称空间，并将所有yaml文件部署到<span> <code>k8s-workshop</code> </span>名称空间中。</p>
<pre><code>danielle@cloudshell:~/k8s-workshop/complete (trial-275916)$ kubectl apply -f 02_webapp/ --namespace k8s-workshop
configmap/webapp created
deployment.extensions/webapp created
horizontalpodautoscaler.autoscaling/webapp created
networkpolicy.networking.k8s.io/app created
secret/webapp created
service/webapp created</code></pre>
<p>接下来，运行<span> <code>kubectl get services --namespace k8s-workshop.</code> </span></p>
<pre><code>danielle@cloudshell:~/k8s-workshop/complete (trial-275916)$ kubectl get services --namespace k8s-workshop
NAME            TYPE           CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE
redis-primary   ClusterIP      10.8.11.78           6379/TCP       19m
redis-replica   ClusterIP      10.8.4.228           6379/TCP       19m
webapp          LoadBalancer   10.8.7.188   34.72.33.15   80:31550/TCP   48s</code></pre>
<p>您可以看到有一个负载平衡器IP挂起。如果你给它几分钟，负载平衡器IP将已经改变。</p>
<p>现在，您已经运行了webapp的前端层。</p>
<h2><strong>访问您的服务</strong></h2>
<p>现在，您可以查看可用的服务，看看您实际上是如何访问webapp的。</p>
<p><code>kubectl -n k8s-workshop get services</code></p>
<p>您可以看到两个服务都连接到Redis，这是只能从集群内部访问的集群IP服务。您还会看到第三个服务webapp，它是公开的，因为它是一个负载平衡器服务。当您列出服务时，您会获得一个外部IP。</p>
<pre><code>danielle@cloudshell:~/k8s-workshop/complete (trial-275916)$ kubectl -n k8s-workshop get services
NAME            TYPE           CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE
redis-primary   ClusterIP      10.8.11.78           6379/TCP       20m
redis-replica   ClusterIP      10.8.4.228           6379/TCP       20m
webapp          LoadBalancer   10.8.7.188   34.72.33.15   80:31550/TCP   97s</code></pre>
<p>如果你复制外部IP，打开一个网络浏览器，你可以看到我们的webapp正在服务来自Kubernetes的Hello。</p>
<p><img src="../Images/6e2676ab1d8cbb0979439e69e90670a6.png" alt="webapp is serving Hello from Kubernetes" srcset="https://www.fairwinds.com/hs-fs/hubfs/webapp%20is%20serving%20Hello%20from%20Kubernetes.jpg?width=351&amp;name=webapp%20is%20serving%20Hello%20from%20Kubernetes.jpg 351w, https://www.fairwinds.com/hs-fs/hubfs/webapp%20is%20serving%20Hello%20from%20Kubernetes.jpg?width=701&amp;name=webapp%20is%20serving%20Hello%20from%20Kubernetes.jpg 701w, https://www.fairwinds.com/hs-fs/hubfs/webapp%20is%20serving%20Hello%20from%20Kubernetes.jpg?width=1052&amp;name=webapp%20is%20serving%20Hello%20from%20Kubernetes.jpg 1052w, https://www.fairwinds.com/hs-fs/hubfs/webapp%20is%20serving%20Hello%20from%20Kubernetes.jpg?width=1402&amp;name=webapp%20is%20serving%20Hello%20from%20Kubernetes.jpg 1402w, https://www.fairwinds.com/hs-fs/hubfs/webapp%20is%20serving%20Hello%20from%20Kubernetes.jpg?width=1753&amp;name=webapp%20is%20serving%20Hello%20from%20Kubernetes.jpg 1753w, https://www.fairwinds.com/hs-fs/hubfs/webapp%20is%20serving%20Hello%20from%20Kubernetes.jpg?width=2103&amp;name=webapp%20is%20serving%20Hello%20from%20Kubernetes.jpg 2103w" sizes="(max-width: 701px) 100vw, 701px" data-original-src="https://www.fairwinds.com/hs-fs/hubfs/webapp%20is%20serving%20Hello%20from%20Kubernetes.jpg?width=701&amp;name=webapp%20is%20serving%20Hello%20from%20Kubernetes.jpg"/></p>
<p>要检查这个特定的pod和pod内的容器是否真的获得了流量，您首先需要获得实际运行的pod的名称:<code>kubectl -n k8s-workshop get pods</code></p>
<p>您将看到有一个webapp pod正在运行。复制pod的全名。</p>
<pre><code>danielle@cloudshell:~/k8s-workshop/complete (trial-275916)$ kubectl -n k8s-workshop get pods
NAME                             READY   STATUS    RESTARTS   AGE
redis-primary-684c84fc56-57brt   1/1     Running   0          25m
redis-replica-d64bd9565-zn7sg    1/1     Running   0          25m
<strong>webapp-54c7b758f5-sxjgp</strong>          1/1     Running   0          6m43s</code></pre>
<p>运行<code>kubectl -n k8s-workshop logs -f <strong>webapp-54c7b758f5-sxjgp</strong></code></p>
<p>您将看到有一个webapp pod正在运行。</p>
<pre><code>10.4.0.1 - - [11/May/2020:20:50:11 +0000] "GET / HTTP/1.1" 200 70 0.0030
10.4.0.1 - - [11/May/2020:20:50:14 +0000] "GET / HTTP/1.1" 200 70 0.0029
10.4.0.1 - - [11/May/2020:20:50:17 +0000] "GET / HTTP/1.1" 200 70 0.0045
10.4.0.1 - - [11/May/2020:20:50:18 +0000] "GET / HTTP/1.1" 200 70 0.0029
10.4.0.1 - - [11/May/2020:20:50:20 +0000] "GET / HTTP/1.1" 200 70 0.0030
10.4.0.1 - - [11/May/2020:20:50:23 +0000] "GET / HTTP/1.1" 200 70 0.0030
10.4.0.1 - - [11/May/2020:20:50:26 +0000] "GET / HTTP/1.1" 200 70 0.0030
10.4.0.1 - - [11/May/2020:20:50:28 +0000] "GET / HTTP/1.1" 200 70 0.0030
10.4.0.1 - - [11/May/2020:20:50:29 +0000] "GET / HTTP/1.1" 200 70 0.0035
10.4.0.1 - - [11/May/2020:20:50:32 +0000] "GET / HTTP/1.1" 200 70 0.0030
10.4.0.1 - - [11/May/2020:20:50:35 +0000] "GET / HTTP/1.1" 200 70 0.0031
10.4.0.1 - - [11/May/2020:20:50:38 +0000] "GET / HTTP/1.1" 200 70 0.0029
10.4.0.1 - - [11/May/2020:20:50:38 +0000] "GET / HTTP/1.1" 200 70 0.0044
10.4.0.1 - - [11/May/2020:20:50:41 +0000] "GET / HTTP/1.1" 200 70 0.0032
10.4.0.1 - - [11/May/2020:20:50:44 +0000] "GET / HTTP/1.1" 200 70 0.0031
10.4.0.1 - - [11/May/2020:20:50:47 +0000] "GET / HTTP/1.1" 200 70 0.0030
10.4.0.1 - - [11/May/2020:20:50:48 +0000] "GET / HTTP/1.1" 200 70 0.0027
10.4.0.1 - - [11/May/2020:20:50:50 +0000] "GET / HTTP/1.1" 200 70 0.0031</code></pre>
<p>您可以查看内部运行状况检查请求，以了解pod是否处于活动状态。如果您返回浏览器并点击refresh，您将会看到针对基本URL的不同git请求通过。您将知道，从公共互联网上，可以访问运行在您的Kubernetes集群中的webapp。</p>
<pre><code>10.4.0.1 - - [11/May/2020:20:51:38 +0000] "GET / HTTP/1.1" 200 70 0.0030
10.4.0.1 - - [11/May/2020:20:51:38 +0000] "GET / HTTP/1.1" 200 70 0.0029
10.4.0.1 - - [11/May/2020:20:51:38 +0000] "GET /favicon.ico HTTP/1.1" 200 37 0.0020
10.128.0.22 - - [11/May/2020:20:51:38 +0000] "GET / HTTP/1.1" 200 70 0.0027
10.128.0.22 - - [11/May/2020:20:51:38 +0000] "GET /favicon.ico HTTP/1.1" 200 37 0.0010
10.128.0.22 - - [11/May/2020:20:51:38 +0000] "GET / HTTP/1.1" 200 70 0.0028
10.128.0.22 - - [11/May/2020:20:51:38 +0000] "GET /favicon.ico HTTP/1.1" 200 37 0.0010
10.128.0.22 - - [11/May/2020:20:51:38 +0000] "GET / HTTP/1.1" 200 70 0.0027
10.4.0.1 - - [11/May/2020:20:51:38 +0000] "GET / HTTP/1.1" 200 70 0.0081
10.128.0.22 - - [11/May/2020:20:51:38 +0000] "GET /favicon.ico HTTP/1.1" 200 37 0.0011
10.128.0.22 - - [11/May/2020:20:51:38 +0000] "GET / HTTP/1.1" 200 70 0.0027
10.128.0.22 - - [11/May/2020:20:51:38 +0000] "GET /favicon.ico HTTP/1.1" 200 37 0.0012
10.4.0.1 - - [11/May/2020:20:51:39 +0000] "GET / HTTP/1.1" 200 70 0.0028
10.4.0.1 - - [11/May/2020:20:51:39 +0000] "GET /favicon.ico HTTP/1.1" 200 37 0.0010
10.4.0.1 - - [11/May/2020:20:51:39 +0000] "GET / HTTP/1.1" 200 70 0.0029
10.4.0.1 - - [11/May/2020:20:51:39 +0000] "GET /favicon.ico HTTP/1.1" 200 37 0.0010
10.128.0.22 - - [11/May/2020:20:51:39 +0000] "GET / HTTP/1.1" 200 70 0.0028
10.128.0.22 - - [11/May/2020:20:51:39 +0000] "GET /favicon.ico HTTP/1.1" 200 37 0.0010
10.128.0.22 - - [11/May/2020:20:51:39 +0000] "GET / HTTP/1.1" 200 70 0.0028
10.128.0.22 - - [11/May/2020:20:51:39 +0000] "GET /favicon.ico HTTP/1.1" 200 37 0.0010
10.4.0.1 - - [11/May/2020:20:51:39 +0000] "GET / HTTP/1.1" 200 70 0.0027
10.4.0.1 - - [11/May/2020:20:51:39 +0000] "GET /favicon.ico HTTP/1.1" 200 37 0.0010
10.4.0.1 - - [11/May/2020:20:51:39 +0000] "GET / HTTP/1.1" 200 70 0.0028
10.4.0.1 - - [11/May/2020:20:51:39 +0000] "GET /favicon.ico HTTP/1.1" 200 37 0.0010
10.4.0.1 - - [11/May/2020:20:51:41 +0000] "GET / HTTP/1.1" 200 70 0.0030</code></pre>
<p>现在，您已经在Kubernetes中部署了一个多层web应用程序。这只是冰山一角，在Kubernetes中有许多方法可以编排工作负载和应用程序。</p>
<p><span class="hs-cta-wrapper" id="hs-cta-wrapper-df6709b9-c7f5-4c1a-8bf4-315f56b16325"><span class="hs-cta-node hs-cta-df6709b9-c7f5-4c1a-8bf4-315f56b16325" id="hs-cta-df6709b9-c7f5-4c1a-8bf4-315f56b16325"><a href="https://cta-redirect.hubspot.com/cta/redirect/2184645/df6709b9-c7f5-4c1a-8bf4-315f56b16325"><img class="hs-cta-img" id="hs-cta-img-df6709b9-c7f5-4c1a-8bf4-315f56b16325" src="../Images/ac3f87548e14243ac3414b06e023028d.png" alt="Just Posted: Kubernetes Benchmark Report 2023" data-original-src="https://no-cache.hubspot.com/cta/default/2184645/df6709b9-c7f5-4c1a-8bf4-315f56b16325.png"/></a></span>T6】</span></p></span></div>    
</body>
</html>