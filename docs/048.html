<html>
<head>
<title>Docker Is Easier to Use Than You Think</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Docker比你想象的更容易使用</h1>
<blockquote>原文：<a href="https://www.fairwinds.com/blog/docker-is-easier-to-use-than-you-think#2019-12-17">https://www.fairwinds.com/blog/docker-is-easier-to-use-than-you-think#2019-12-17</a></blockquote><div><span id="hs_cos_wrapper_post_body" class="hs_cos_wrapper hs_cos_wrapper_meta_field hs_cos_wrapper_type_rich_text" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p>在我的<a href="http://blog.reactiveops.com/docker-is-a-valuable-devops-tool-one-thats-worth-using">上一篇博文</a>中，我关注了为什么<a href="https://www.docker.com/" target="_blank"> Docker </a>对使用有益，以及为什么它在广泛的用例中提供了重要的价值。在本系列的第二部分中，我将重点讨论为什么使用它没有您想象的那么困难。</p>
<p>下面，我将分享一些基本的命令和例子来告诉你Docker是多么容易使用。首先，您需要在您的系统上运行Docker。转到此处，按照与您的系统相匹配的说明进行操作。准备好了，我们就从最常见的Docker函数开始，<span> </span> <code>docker run</code>。</p>
<h2 id="how-to-run-docker">如何运行Docker</h2>
<p>Docker在隔离的容器中运行进程(在本地或远程主机上运行的进程)。当您执行docker run命令时，运行的容器进程是独立的——它有自己的文件系统、自己的网络和自己独立于主机的进程树。</p>
<p>基本的<span> </span> <code>docker run</code> <span> </span>命令采用这种形式:</p>
<p><code>$ docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]</code></p>
<p>下面是一个运行redis映像的非常简单的示例:</p>
<p><code>docker run redis</code></p>
<p>如果您的主机上还没有redis映像，它会为您提取映像。看着每个文件系统层被并行下载，然后一个运行redis的容器启动。Ctrl-C并再次运行该命令，您将会看到由于已经下载了映像，后续运行的速度有多快。</p>
<p>下面是另一个更复杂的例子，展示了如何运行一个<a href="https://www.python.org/download/releases/3.0/" target="_blank"> Python 3.0 </a> (python3)图像:</p>
<p><code>docker run -p 8080:8080 python:3 python3 -m http.server 8080</code></p>
<p>我们来分解一下上面的命令:</p>
<p>- <code>docker run: run a docker container</code></p>
<p>- <code>p 8080:8080</code>:将容器内部的端口8080映射到容器外部的端口8080。</p>
<p>- <code>python:3</code>:使用标签为3的python图像。本例中的<span> </span> <code>image:tag</code> <span> </span>组合表明该图像正在运行python3。</p>
<p>- <code>python3 -m http.server 8080</code>:在容器内部运行这个命令。</p>
<p>该命令运行python3二进制文件，加载<span> </span> <code>http.server</code> <span> </span>模块，并创建一个在端口8080上可用的web服务器。上面的<span> </span> <code>-p</code> <span> </span>选项映射了端口，应该允许您访问<span> </span> <code>http://localhost:8080</code> <span> </span>并查看运行容器内的目录列表。</p>
<p>如果您还没有在您的开发环境中运行Python3，那么要执行多少步才能得到这个命令的等价物？</p>
<h2 id="other-common-docker-commands">其他常见的Docker命令</h2>
<p>还有更多的选项和命令，但这些将使您快速开始使用Docker:</p>
<p>- <code>docker images</code>:展示你的主持人是什么形象</p>
<p>- <code>docker ps</code>:显示哪些容器</p>
<p>- <code>docker ps -a</code>:显示所有正在运行或已经运行但尚未移除的容器</p>
<p>- <code>docker stop &lt;container id&gt;</code>:停止正在运行的容器</p>
<p>- <code>docker rm &lt;container id&gt;</code>:移除容器</p>
<p>- <code>docker rmi &lt;image&gt;</code>:删除图像</p>
<h2 id="useful-docker-run-flags">有用的Docker运行标志</h2>
<p>要在分离模式下启动容器，请使用<span> </span> <code>-d</code> <span> </span>标志。按照设计，当用于运行容器的根进程退出时，以分离模式启动的容器也会退出。</p>
<p><code>docker run -d -p 6379:6379 redis</code></p>
<p>将启动一个redis容器，在后台运行它并使其在<span> </span> <code>localhost:6379</code>可用。</p>
<p>使用<span> </span> <code>docker ps</code> <span> </span>查找容器ID，<span> </span> <code>docker stop</code> <span> </span>停止它，使用<span> </span> <code>docker rm</code> <span> </span>删除它。</p>
<p>要发布或公开端口，请使用<span> </span> <code>-p</code> <span> </span>标志。</p>
<p>- <code>docker run python:3 python3 -m http.server 8080</code></p>
<p>- <code>http://localhost:8080/</code></p>
<p>- <code>http://localhost:8080/</code></p>
<p>在上面的第一个示例中，您没有打开容器中的端口(您无法访问正在运行的Python服务器)，而第二个示例演示了网络地址转换(您可以访问服务器)。</p>
<p>要绑定挂载卷，请使用<span> </span> <code>-v</code> <span> </span>标志。</p>
<p>下面的示例展示了这三个标志的用法:</p>
<p><code>docker run -d -v /docker/redis/data/:/data/ -p 3306:3306 redis</code></p>
<p>在这种情况下，容器内的路径'/data '被映射到主机上的<span> </span> <code>/docker/redis/data</code> <span> </span>。这是在docker运行之间保存状态的一种方式。</p>
<h2 id="how-to-get-logs-from-docker">如何从Docker获取日志</h2>
<p><span> </span> <code>docker logs</code> <span> </span>命令获取容器的日志。</p>
<p>该命令采用以下形式:</p>
<p><code>docker logs [OPTIONS] CONTAINER</code></p>
<h2 id="how-to-run-docker-interactive-shell">如何运行Docker交互式Shell</h2>
<p>标签<span> </span> <code>–it</code> <span> </span>使您能够在运行的容器上交互并打开外壳。它创建了一个交互式的附加终端。</p>
<p>下面的例子展示了如何在Ubuntu映像中运行交互式shell:</p>
<p><code>docker run -it ubuntu bash</code></p>
<h2 id="images-containers-and-repositories">图像、容器和存储库</h2>
<p>Docker映像是文件系统层的集合，相当于一个固定的起点。运行映像时，它会创建一个容器。从初始映像所做的一组更改稍后会成为一个附加的文件系统，并且可以提交容器，此时它会成为一个新的映像。存储库是存储图像的地方。</p>
<p><span> </span> <code>docker pull</code> <span> </span>和<span> </span> <code>docker push</code> <span> </span>命令将使您能够与您的存储库进行交互，以执行对接拉或对接推。使用<span> </span> <code>docker pull</code> <span> </span>将容器映像从注册表下载到本地缓存中，这样您就可以基于映像启动容器。使用<span> </span> <code>docker push</code> <span> </span>将您的图像共享到<a href="https://hub.docker.com/" target="_blank"> Docker Hub </a>注册表或自托管注册表。</p>
<h2 id="how-to-build-images-using-dockerfile">如何使用Dockerfile构建图像</h2>
<p>一个图像通常用一个<span/><a href="https://docs.docker.com/engine/reference/builder/" target="_blank"><em>docker file</em></a>来定义，它包含了你可以在命令行上调用的所有命令来组装一个图像。每个图像都从一个基础图像开始，比如ubuntu(一个基础<a href="https://www.ubuntu.com/" target="_blank"> Ubuntu </a>图像)。</p>
<p><code>docker build . -t &lt;whatever you want to name the image&gt;</code></p>
<p>Docker通过读取docker文件中的指令来构建映像。这一部分很重要:docker文件中的每个docker命令代表一个文件系统层。每次构建映像时，它将使用以前构建的缓存层。docker文件中的任何一行发生变化都会使其下所有命令(和层)的缓存失效。</p>
<p>那是什么意思？</p>
<p>让我们假设你有一个简单的项目。你要把一个<span> </span> <code>simple_script.sh</code> <span> </span>放入Docker镜像，而<span> </span> <code>simple_script.sh</code> <span> </span>依赖于telnet。您需要将脚本复制到映像中并安装telnet。</p>
<p>如果我们的docker文件是:</p>
<p>- <code>FROM ubuntu</code></p>
<p>- <code>COPY simple_script.sh /</code></p>
<p>- <code>RUN apt-get update</code></p>
<p>- <code>RUN apt-get install -y vim</code></p>
<p>- <code>CMD “bash simple_script.sh”</code></p>
<p>然后每次更新<span> </span> <code>simple_script.sh</code>，构建过程都会再次运行<span> </span> <code>apt-get update</code> <span> </span>和<span> </span> <code>apt-get install</code> <span> </span>。这将很快过时，因此您可以将docker文件重组为:</p>
<p>- <code>FROM ubuntu</code></p>
<p>- <code>RUN apt-get update &amp;&amp; apt-get install -y vim</code></p>
<p>- <code>COPY simple_script.sh /</code></p>
<p>- <code>CMD “bash simple_script.sh”</code></p>
<p>你已经完成了两件事。首先，通过使用<span> </span> <code>&amp;&amp;</code> <span> </span>操作符并结合<span> </span> <code>apt-get update</code> <span> </span>和<span> </span> <code>apt-get install</code> <span> </span>命令，文件系统的层数减少了一层。第二，当你现在更改<span> </span> <code>simple_script.sh</code> <span> </span>并运行<span> </span> <code>docker build</code> <span> </span>时，apt命令会被缓存，后续构建只需要添加<span> </span> <code>simple_script.sh</code>。这加速了发展，让每个人都更开心。</p>
<h2 id="start-using-docker">开始使用Docker</h2>
<p>你可能仍然对使用Docker犹豫不决。可以理解。要克服任何感觉到的障碍，从小事做起，从简单做起。从简单的流程开始，在有限的范围内使用这些流程——记住，您希望每个容器运行一个流程。</p>
<p>Docker是一个非常棒的工具。我希望您能尝试一下上面的命令，并决定利用Docker提供的所有好处。</p></span></div>    
</body>
</html>