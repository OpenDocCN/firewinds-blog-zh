<html>
<head>
<title>Gemini: Automate Backups of PersistentVolumes in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Gemini:自动备份Kubernetes中的持久卷</h1>
<blockquote>原文：<a href="https://www.fairwinds.com/blog/gemini-automate-backups-of-persistentvolumes-in-kubernetes#2022-12-12">https://www.fairwinds.com/blog/gemini-automate-backups-of-persistentvolumes-in-kubernetes#2022-12-12</a></blockquote><div><span id="hs_cos_wrapper_post_body" class="hs_cos_wrapper hs_cos_wrapper_meta_field hs_cos_wrapper_type_rich_text" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p> </p><h2><strong>持久存储很难</strong></h2>


<p>当我第一次开始掌握Kubernetes时，我想用它做任何事情。在多年点击AWS控制台上的按钮后，拥有一个开源、代码驱动、独立于供应商的云平台的想法非常令人兴奋。因此，当我得知我的同事——我见过的一些最强的Kubernetes专家——强烈反对在Kubernetes中运行数据库，或将其用于任何类型的持久存储时，我感到很沮丧。他们告诉我坚持使用S3和RDS来满足我的存储需求。</p>
<p> </p>
<p>当然，我没有听。虽然我们(谢天谢地)在设计生产应用程序时采纳了他们的建议，但我已经开始使用Kubernetes运行一些个人应用程序，比如照片共享和记笔记。我将所有数据存储在persistent volumes(PV)上，甚至想出了一个简单的方法将数据备份到S3。而且效果很好！</p>
<p> </p>
<p>直到它没有。在某个时候，当更新我的一个应用程序时，我意外地删除了一个持久卷，却发现我的备份没有正常工作。几周的写作就这样消失了。</p>
<p> </p>
<p> </p><h2><strong>寻找解决方案</strong></h2>

<div><p>我没有被吓倒，开始寻找更成熟的备份解决方案。</p><a target="_blank" data-target-href="https://github.com/vmware-tanzu/velero" href="https://github.com/vmware-tanzu/velero" rel="nofollow noopener">Velero</a><p>似乎是一个社区的最爱，但更多的是重量级的灾难恢复，而不是我需要的有针对性的应用程序备份解决方案。</p><a target="_blank" data-target-href="https://github.com/miracle2k/k8s-snapshots" href="https://github.com/miracle2k/k8s-snapshots" rel="noreferrer nofollow noopener">k8s-snapshots</a><p>相当有前途——它直接与AWS、GCP和DigitalOcean APIs集成，以创建PVs基础卷的备份。我让它运行了一段时间，直到我发现恢复被认为是</p><a target="_blank" data-target-href="https://github.com/miracle2k/k8s-snapshots/issues/38" href="https://github.com/miracle2k/k8s-snapshots/issues/38" rel="noreferrer nofollow noopener">out-of-scope</a><p>为了项目！如果不能将备份重新连接到正在运行的应用程序，这些备份几乎毫无用处。</p></div>
<p>最后，我了解了</p>
<div><p>，一个k8s原生备份解决方案，从1.17开始进入测试版。它代表了一个巨大的进步</p><a target="_blank" data-target-href="https://kubernetes.io/docs/concepts/storage/volume-snapshots/" href="https://kubernetes.io/docs/concepts/storage/volume-snapshots/" rel="noreferrer nofollow noopener">VolumeSnapshot API</a><p>，这是Kubernetes中处理持久存储的官方方法。每个主要的云供应商都提供CSI挂钩，允许您使用Kubernetes-native接口管理他们云中的卷和备份。</p><a target="_blank" data-target-href="https://kubernetes.io/blog/2019/01/15/container-storage-interface-ga/" href="https://kubernetes.io/blog/2019/01/15/container-storage-interface-ga/" rel="noreferrer nofollow noopener">Container Storage Interface</a><a target="_blank" data-target-href="https://kubernetes.io/blog/2019/01/15/container-storage-interface-ga/" href="https://kubernetes.io/blog/2019/01/15/container-storage-interface-ga/" rel="noreferrer nofollow noopener"> </a><a target="_blank" data-target-href="https://kubernetes.io/blog/2019/01/15/container-storage-interface-ga/" href="https://kubernetes.io/blog/2019/01/15/container-storage-interface-ga/" rel="noreferrer nofollow noopener">(CSI)</a><p> </p></div>
<p>这正是我所需要的！但有一个问题:卷快照必须手动创建。最终用户需要决定如何管理他们的快照，不仅要按计划创建新快照，还要淘汰旧快照以防止它们堆积。存储可能很便宜，但是每小时备份一个1GB的卷会很快变得昂贵！</p>
<p> </p>
<p><strong>创造双子座</strong></p>
<div>
<h2><strong><img src="../Images/3b8b6febde94ba1e2244cb39379cc478.png" alt="Gemini by Fairwinds" srcset="https://www.fairwinds.com/hs-fs/hubfs/gemini_bfw_color.png?width=341&amp;name=gemini_bfw_color.png 341w, https://www.fairwinds.com/hs-fs/hubfs/gemini_bfw_color.png?width=681&amp;name=gemini_bfw_color.png 681w, https://www.fairwinds.com/hs-fs/hubfs/gemini_bfw_color.png?width=1022&amp;name=gemini_bfw_color.png 1022w, https://www.fairwinds.com/hs-fs/hubfs/gemini_bfw_color.png?width=1362&amp;name=gemini_bfw_color.png 1362w, https://www.fairwinds.com/hs-fs/hubfs/gemini_bfw_color.png?width=1703&amp;name=gemini_bfw_color.png 1703w, https://www.fairwinds.com/hs-fs/hubfs/gemini_bfw_color.png?width=2043&amp;name=gemini_bfw_color.png 2043w" sizes="(max-width: 681px) 100vw, 681px" data-original-src="https://www.fairwinds.com/hs-fs/hubfs/gemini_bfw_color.png?width=681&amp;name=gemini_bfw_color.png"/>T2】</strong></h2>
<p>我们希望给VolumeSnapshot API一个更健壮、用户友好的界面。具体来说，我们认为以下功能是任何生产级备份策略所必需的:</p>
</div>
<p> </p>
<p>根据可定制的细粒度计划自动备份</p>
<ul>
<li>自动删除过时的备份</li>
<li>从特定备份中轻松恢复数据的能力</li>
<li>因此，我们决定创建一个新项目Gemini，以便自动化持久卷的备份和恢复。Gemini由一个新的CRD(快照组)和一个根据快照组规范创建、删除和恢复卷快照的操作器组成。它是这样工作的。</li>
</ul>
<p><span class=" author-d-1gg9uz65z1iz85zgdz68zmqkz84zo2qoxw4z74zjbnz71zz87zz88zyj0flp65idsz83zz82zz87zz87zuz72zz86zz90ztgz81z">我们从快照组定义开始，它看起来像这样:</span></p>
<p>在这里，我们告诉Gemini找到现有的postgres-data PVC，并安排每10分钟备份一次——这可能有点过分，但安全总比后悔好。除了最新的备份，我们还告诉Gemini保留最近的三个备份，这样我们至少有30分钟的覆盖时间。</p>
<pre><code>apiVersion: gemini.fairwinds.com/v1beta1<br/>kind: SnapshotGroup<br/>metadata:<br/>  name: postgres-backups<br/>spec:<br/>  persistentVolumeClaim:<br/>    claimName: postgres-data<br/>  schedule:<br/>  - every: 10 minutes<br/>    keep: 3
</code></pre>
<p>但是我们可以更进一步！我们还可以告诉Gemini保持每小时、每天、每周、每月和每年的快照:</p>
<p>Gemini仍将每10分钟运行一次备份，但它将保留额外的备份以满足长期备份计划。</p>
<pre><code>apiVersion: gemini.fairwinds.com/v1beta1<br/>kind: SnapshotGroup<br/>metadata:<br/>  name: postgres-backups<br/>spec:<br/>  persistentVolumeClaim:<br/>    claimName: postgres-data<br/>  schedule:<br/>    - every: 10 minutes<br/>      keep: 3<br/>    - every: hour<br/>      keep: 1<br/>    - every: day<br/>      keep: 1<br/>    - every: week<br/>      keep: 1<br/>    - every: month<br/>      keep: 1<br/>    - every: year<br/>      keep: 1
</code></pre>
<p><span>恢复数据</span></p>
<h2>从卷快照恢复数据可能有点麻烦，因为不幸的是，不停机就不可能完成。我们需要采取以下步骤:</h2>
<p> </p>
<p>关闭正在使用PVC的任何盒</p>
<ul>
<li>为当前状态的PVC创建一次性备份，以防万一</li>
<li>删除现有的PVC</li>
<li>从所需的卷快照创建新的PVC</li>
<li>重启我们的pod，将它们指向新的PVC</li>
<li>因为更换PVC必然会导致停机，所以我们决定不对用户隐藏这个过程。具体来说，用户负责第一步和最后一步，即缩小和备份应用程序。Gemini负责中间部分，替换掉PVC。</li>
</ul>
<p> </p>
<p>下面是基本的恢复过程。首先，我们将检查哪些快照可用:</p>
<p>注意时间戳，<code>1585945609</code> -这是我们的目标还原点:15分钟前。接下来，我们将缩小应用程序的规模:</p>
<pre><code>$ kubectl get volumesnapshot
NAME                           AGE
postgres-backups-1585945609    15m</code></pre>
<p>由于我们的应用程序处于离线状态，我们现在需要快速移动。要换出PVC，我们只需用所需的还原点来注释快照组:</p>
<pre><code>kubectl scale all --all --replicas=0</code></pre>
<p>一旦Gemini看到此注释，它将触发一次性备份，删除旧PVC，并使用指定快照中的数据用新PVC(同名)替换它。恢复应该只需要30秒左右。与此同时，我们可以扩大规模，一旦新的PVC准备就绪，我们的pod就会上线。</p>
<pre><code>kubectl annotate snapshotgroup/postgres-backups --overwrite \
  "gemini.fairwinds.com/restore=1585945609"
</code></pre>
<p>不幸的是，恢复数据需要一点停机时间，而且似乎没有任何合理的方法来解决这个问题。如果您对如何改进这一流程有任何想法，请通过<a href="https://github.com/FairwindsOps/gemini/issues" rel=" noopener">提出问题</a>告诉我们！</p>
<pre><code>kubectl scale all --all --replicas=1
</code></pre>
<p>同样值得注意的是，您可以从一个备份中启动第二个PVC，并将其附加到应用程序的一个单独实例中。我使用这种机制来恢复旧照片，而不必将我的整个照片应用程序恢复到特定的时间点。</p>
<p>前进</p>
<pre><code>apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: restore-pvc<br/>spec:<br/>  dataSource:<br/>    name: postgres-backups-1585945609<br/>    kind: VolumeSnapshot<br/>    apiGroup: snapshot.storage.k8s.io<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 1Gi
</code></pre>
<p>我对VolumeSnapshot API感到非常兴奋，因为它填补了Kubernetes生态系统中的一个巨大空白。当与Gemini结合使用时，它允许我们在Kubernetes中安全地维护持久存储。虽然这里仍然有一些龙(毕竟卷快照仍处于测试阶段)，但我期待有一天Fairwinds可以自信地推荐使用独立于供应商的k8s原生存储解决方案，如</p><h2>和</h2>

<div><p>像S3和RDS这样的服务。</p><a target="_blank" data-target-href="https://github.com/bitnami/charts/tree/master/bitnami/minio" href="https://github.com/bitnami/charts/tree/master/bitnami/minio" rel="nofollow noopener">MinIO</a><p> </p><a target="_blank" data-target-href="https://github.com/bitnami/charts/tree/master/bitnami/postgresql-ha" href="https://github.com/bitnami/charts/tree/master/bitnami/postgresql-ha" rel="noreferrer nofollow noopener">PostgreSQL-HA</a><p>与此同时，我将享受边缘生活，使用Gemini和VolumeSnapshots管理我的个人数据。</p></div>
<p> </p>
<p>In the meantime, I’ll be enjoying life on the edge, using Gemini and VolumeSnapshots to manage my personal data.</p></span></div>    
</body>
</html>